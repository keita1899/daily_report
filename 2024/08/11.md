# 8/11

## 取り組んだこと

- サバイバル TypeScriptc
  - 4 章
  - 5 章

## 学んだこと

### サバイバル TypeScriptc

- 4 章 読んで学ぶ TypeScript

  - 値・型・変数
    - `const`は再代入ができないが、オブジェクトのプロパティと配列の要素は変更できる
    - 型を指定することを型注釈または型アノテーションという
    - `let`と`var`で初期値を指定せずに宣言すると`undefined`になる
    - `var`は同じ名前を宣言してもエラーにならず後の宣言が有効になる
    - `var`はグローバルスコープで宣言すると`window`オブジェクトのプロパティになってしまう
    - `var`は変数の巻き上げによってスコープの先頭で変数が生成され`undefined`で初期化されるため、宣言より前で使ってもエラーにならない
    - 型推論によって一度型が決まると、その後も同じ型として振る舞う、一方動的型付けは実行するタイミングによって型が変わる
    - プリミティブ型は一度値が決まると変更できないイミュータブルの特性を持つ
    - JavaScript では自動ボックス化によってプリミティブ型をオブジェクトのように使える
    - 自動ボックス化の変換先となるオブジェクトをラッパーオブジェクトという
    - TypeScript で使える`Boolean`と`boolean`、`Number`と`number`は別の型
    - JavaScript では整数と小数は同じ`number`型
    - `NaN`は処理の結果が数値にならない非数を表す変数
    - JavaScript ではシングルクォートでもダブルクォートでも同じ`string`型
    - `null`に対して型を調べる`typeof`を使うと`"object"`が返る
    - `undefined`は未定義を表すプリミティブな値で、型は`undefined`を指定する
    - JavaScript では自然に`null`が発生することはほぼない
    - `undefined`は変数で、`null`はリテラル
    - 値がないことを`null`に統一すると記述が増えるため、`undefined`に統一する方が良い
    - `bigint`と`number`はそのままでは一緒に演算できない
    - ラッパーオブジェクトにも型があるが、プリミティブ型に代入できず、演算子も使えないので、型注釈に使うメリットはない
    - プリミティブ型の特定の値だけを代入可能にする型をリテラル型といい、主にマジックナンバーやステートの表現に使われる
    - リテラル型で使えるのは`boolean`の`true`、`false`、`number`の値、`string`の文字列
    - `any`型はどんな型でも代入を許す型で、コンテキストから型を推論できない場合は暗黙的に`any`になる
    - 既存のプロジェクトに TypeScript を導入するときに、コンパイルエラーを解消してとりあえず動くようにするために`any`型を使う
    - オブジェクトリテラルによってクラスを使わずに簡単にオブジェクトを定義できる
    - JSON の由来はオブジェクトリテラル
    - JavaScript ではプロパティとメソッドは同じように扱われる
    - オブジェクトの型注釈でのプロパティの区切り文字にはカンマよりセミコロンを使う
    - メソッドの型注釈は引数と戻り値の型を指定する
    - `object`型も存在するが、何のプロパティがあるか分からず、どんなオブジェクトでも代入できてしまうので使わない
    - TypeScript では`readonly`を指定することでオブジェクトのプロパティを読み取り専用にできる
    - `Readonly`を使えばすべてのプロパティを読み取り専用にできる
    - `const`は変数自体の代入を不可するもので、`readonly`は変数自体は再代入できる
    - オブジェクトのプロパティに`?`をつけると、そのプロパティを持たないオブジェクトを代入できる
    - TypeScript ではオブジェクトリテラルの代入で余分なプロパティは許可されない（変数代入では許可される）
    - オブジェクトの生成方法にはクラスベースとプロトタイプベースがある
    - プロトタイプベースでは既存のオブジェクトを元にオブジェクトを生成する
    - プロトタイプベースでの継承はオブジェクトの生成方法と変わらない
    - JavaScript がプロトタイプベースを採用したのは、クラスよりシンプルで柔軟性が高いため
    - `object`型はオブジェクトだけが代入でき、`Object`型は`null`と`undefined`を除くプリミティブ型も含めたオブジェクトを代入でき、`{}`型はプロパティを持たないオブジェクトを表す
    - オブジェクトのキーと変数名が同じ場合は省略して書ける
    - JavaScript では`null`や`undefined`のプロパティを参照するとエラーになる
    - `?.`で参照したプロパティが`null`か`undefined`の時は`undefined`になる
    - 型の割り当ての決まりには名前が同じであれば型が同じとする名前的部分型と、構造が同じであれば型が同じとする構造的部分型の２種類があり、TypeScript では構造的部分型
    - 配列の型の指定は`number[]`か`Array<number>`の２種類の書き方がある
    - 配列をコピーしても値ではなく参照がコピーされるため、配列のコピーにはスプレッド構文を使う
    - TypeScript でも存在しない要素へのアクセスでコンパイラは警告しないため、コンパイラオプションの`noUncheckedIndexedAccess`を有効にすべき
    - 配列を読み取り専用にすると破壊的メソッドの呼び出しでコンパイラに警告される
    - 読み取り専用の配列を普通の配列に代入できない
    - 破壊的メソッドを使う時は配列をコピーしてから使うべき
    - `for-in`は順番通りになる保証がないので、配列のループでは使わない
    - スプレッド演算子は 1 走目の要素だけを複製する浅いコピーなので、深いコピーをするには`concat`メソッドを使う
    - 共変とはその型自身と、部分型を代入できることで、Animal 変数に Animal 自身と Dog を代入できるが、Dog 型に Animal を代入できない
    - 列挙型には`enum`を使うが、いくつか問題点があるため、代替案としてユニオン型を使うか、オブジェクトリテラルを使うことを検討する
    - ユニオン型は 2 つ以上の型を`|`でつなげてどれかに一致する型で、配列では`T[]`の形式の場合`()`が必要
    - インターセクション型は`&`で繋げた型のすべてに一致する必要がある型で、プリミティブ型をつなげると`never`型になる
    - `type`を使って型に名前をつけることを型エイリアスといい、型の再利用に便利
    - `as`を使って型推論を上書きする機能を型アサーションという
    - 型アサーションはキャストと似ているがコンパイル時にコンパイラーに型を伝えるだけで、型の変換はしない
    - 型アサーションはやむを得ない場合に使うべき
    - オブジェクトリテラルの末尾に`as const`を記述すると`readonly`とほぼ同じ扱いになる
    - `as const`だと再帰的に読み取り専用にできる
    - `typeof`で配列を判断すると`"object"`になる
    - `NaN`同士の比較は false になる
  - 文
    - レキシカルスコープは関数を定義した地点から参照できる関数外の変数
    - TypeScript では変数宣言されていない変数に代入しようとするとコンパイラに指摘される
    - 三項演算子は条件をネストできる
    - 配列をループするには`for-of`を使う
    - `switch`文は厳密等価
    - TypeScript では`switch`文のフォールスルーを`noFallthroughCasesInSwitch`で警告できる
    - `case`ではスコープがないので、`{}`を使う
    - 例外処理では、プリミティブ型も投げれるが、スタックトレースを扱える`Error`オブジェクトを投げるべき
    - `catch`の変数の型はデフォルトで`any`型になる
    - コンパイラオプションの`useUnknownInCatchVariables`を有効にすると、`catch`の変数の型が`unknown`型になる
    - `catch`は 1 つしか書けないので、エラーハンドリングを分岐する場合は普通に if 文を使う
    - `never`は値を持たないことを意味する型で、何も代入できない
    - 値がないとは、例外が必ず発生する関数や終了しない無限ループの関数の戻り値
    - `void`型は`undefined`が代入でき、関数が最後まで実行されることを意味するが、`never`は代入できず、処理が中断もしくは永遠に続くことを意味する
    - 網羅性チェックはユニオン型を分岐処理するときにロジックがすべてのパターンを網羅しているかコンパイラにチェックさせること
    - `unknown`型は型が何かわからないときに使う型で、どんな値でも代入できる
    - `unknown`型の値は具体的な型へ代入できず、プロパティやメソッドへのアクセスもできないので`any`型より安全に使える
    - 型を絞り込むときに使う`typeof`や`instanceof`は型ガードといい、絞り込んだ型はそれ以降の処理で使える
    - 配列型に絞り込むには`Array.isArray()`を使う
    - 新規でアプリを作る場合は、`tsconfig.json`で`noImplicitAny`を指定して`any`を防ぐとよい
  - 関数
    - 引数の型注釈を省略した場合は`any`型になる
    - 戻り値の型注釈を省略した場合は型推論が行われる
    - 関数型の変数に関数式を代入する場合、引数の型注釈を省略しても型推論が行われる
    - 関数式の関数名は再帰的に呼び出す場合に使える
    - アロー関数の引数の`()`を省略した場合は引数と戻り値のどちらも型注釈を書けない
    - 関数の型は型エイリアスで定義する
    - `typeof`を使えば関数の実装から型を宣言できる
    - 関数の型宣言は関数宣言の型注釈では使えない
    - 関数宣言では巻き上げがあり、関数式では巻き上げがない
    - 定義する前に関数を実行しようとするとコンパイラに警告される
    - アロー関数と、TypeScript での従来の関数はコンストラクタになれない
    - アロー関数の`this`はレキシカルスコープの`this`を指す
    - アロー関数では引数の重複はエラーになる
    - TypeScript での従来の関数とアロー関数では安全面での差はない
    - 戻り値型が`undefined`型の場合は`return`がないとコンパイルエラーになる
    - TypeScript では関数の引数の数が一致していないとコンパイルエラーになる
    - JavaScript の関数では値渡しになるが、オブジェクトの場合は値を共有する
    - 引数に`?`をつけるオプション引数を使うことで関数を呼び出す際の引数を省略できる
    - 引数を省略した時の型は`undefined`になる
    - オプション引数の後には引数を書けない
    - 引数の値が`undefined`のとき代わりの値を指定できるのがデフォルト引数
    - 残余引数は最後の引数である必要がある
    - 残余引数は配列の型で型注釈をする
    - アロー関数以外の関数とクラスのメソッドの第 1 引数は this という特殊な引数を受けることができる
    - 分割代入は関数の引数でも使える
    - JavaScript では分割代入の引数がない場合`undefined`になるが、TypeScript ではコンパイルエラーになる
    - JavaScript、TypeScript では`名前=値`のようなキーワード引数は使えない
    - 一つのオブジェクトを引数に受け取るように設計された関数を Options Object パターンという
    - Options Object パターンによって、引数の値の意味がわかりやすい、引数追加時に変更が少ない、デフォルト引数を省略できるメリットがある
    - 型ガードを使うことで if 文で特定の型に絞り込むことができる
    - TypeScript での if や switch は構文であり式ではないため、判定結果を変数に代入することができないが、即時関数を使うことで代入できる
    - コールバック関数には同期型と非同期型があり、非同期型の場合 Promise の結果を解決する必要がある
    - オーバーロード関数は TypeScript の機能で、一つの関数に異なる関数シグネチャを複数持つ関数
    - オーバーロード関数はシグネチャと実装に分けて書く
  - 非同期処理
    - Promise の型を指定する場合はジェネリクスを使って`Promise<T>`と書き、`T`には Promise が履行されたときに返す値の型を指定する（`T`は必須）
    - Promise には待機中の`pending`、履行の`fullfilled`、拒否の`reject`の 3 つの状態がある
    - `async`をつけると関数内で Promise が返されていなくても戻り値の型を Promise で包んで返すようになる
    - 関数を作らずに Promise を直接`await`できる
  - オブジェクト指向
    - コンストラクタ関数の型注釈は関数と同じ
    - TypeScript のクラスではフィールドに型注釈が必要
    - TypeScript は、クラスの宣言に書かれていないフィールドへアクセスした場合、コンパイルエラーになる
    - アクセス修飾子は制限を緩める方向にだけ変更できる
    - メソッドの引数にアクセス修飾子は指定できないが、コンストラクタには指定できる
    - TypeScript ではフィールドに`readonly`をつけると読み取り専用にできる
    - クラスはオブジェクトだが、TypeScript では型安全のためにクラスを動的に拡張できない
    - JavaScript では静的フィールド（クラスのプロパティ）と静的メソッド（クラスメソッド）はないが、TypeScript では`static`を使える
    - サブクラスにコンストラクタを書く場合、`super()`を使ってスーパークラスのコンストラクタは必ず呼び出す必要がある
    - `instanceof`は特定のオブジェクトがクラスのインスタンスであるか確認するメソッド
    - JavaScript には抽象クラスはないが、TypeScript には`abstract`修飾子がある
    - 抽象クラスで実装したものを JavaScript にコンパイルすると消されずに残る
    - JavaScript・TypeScript には継承できないクラスである final クラスや、他のモジュールでは継承できない sealed クラスは存在しない
    - インターフェースはクラスが定義すべきフィールドやメソッドを定義した型で、JavaScript にはないが TypeScript では実装できる
    - インターフェースを使うには`implements`を使い、複数指定することもできる
    - インターフェースは継承できる
    - TypeScript ではインターフェースと実装関係がないオブジェクトの型注釈としても使える
    - TypeScript では、同じ名前のインターフェースを宣言してもエラーにはならずマージされる（宣言マージ）
    - 宣言マージはバージョンアップでインターフェースを拡張する際に使われる
    - インターフェースはコンパイルすると消えるため、`instanceof`は使えない
    - 抽象クラスには`instanceof`は使える
    - 型エイリアスは継承できず、同名のものを定義してもエラーになる
  - JSX
    - JSX は ECMAScript の言語仕様にないため、トランスパイルが必要
    - `??`を使うと最初のオペランドが`null`または`undefined`の場合に 2 番目の値を返す
    - React では DOM の変更を効率的に追跡するために、配列内の要素の一意の`key`プロパティを追加することが推奨される
    - 属性の値が`true`の場合は属性名だけを記述する
  - 組み込み API
    - Map の型注釈は`Map<string, number>`のように書く
    - Map は直接 JSON にできないので、一度オブジェクトにする必要がある
    - Map はキーに任意の型が使える
    - 空の Set オブジェクトの TypeScript 上の型は`Set<unknown>`になる
    - Set の型注釈は`Set<string>`のようになる
    - Date オブジェクトは、常識的には存在しない日付を解析しようとすると自己補正を試みたり、フォーマットのための関数を自作する必要があったり、ローカルのタイムゾーンで時間を表示するので、複雑な処理にはライブラリを使うことが推奨される
    - RegExp は正規表現のための組み込みクラスで、リテラル表記とコンストラクタ表記の 2 通りある
    - Error は例外を扱うオブジェクト
    - JavaScript ではどんな値でも`throw`できる
    - Error にはサブクラスがあり、サブクラスを自作することもできる
    - JavaScript はどのような値も`throw`できるので`catch`した値の型は定まらず`any`型か`unknown`型として解釈される
  - import、export、require
    - `import`は必ずファイルの一番上に書く必要がある
    - named export を使うと呼び出し元の変更を強制できる
  - シングルプロセス・シングルスレッドとコールバック
    - シングルスレッドの言語はコールスタックも１個
    - 直接に処理される時の時間のかかる処理によって他の処理が実行されないことをブロッキングという
    - ブロッキングと逆の、処理が終わるまで待たずにすぐに呼び出し元に結果を返し、追って別の方法で結果を伝える方式をノンブロッキングという
  - 型の再利用
    - 既存の型を再利用して新たな型を生み出すことを型の再利用という
    - TypeScript の`typeof`は変数から型を抽出する型演算子
    - ユーティリティ型(utility type)は、型から別の型を導き出してくれる型
  - ジェネリクス
    - ジェネリクスは型を変数のように使うことで、型の安全性とコードの共通化を両立するための機能
    - 型変数名の定義は慣習的に`<T>`がよく使われる
    - ジェネリクスはさまざまな形に対応する必要がある標準ライブラリでも使われる
    - 型引数は型変数に代入した型のこと
    - 型変数が 2 つある場合は、T と U が使われることが多い
    - `extends`を使うことで、ジェネリクスの型を特定の型に限定できる
    - ジェネリクスでもデフォルトの型引数を指定することができる
  - tsconfig
    - `tsconfig.json`は TypeScript の設定ファイルで、`npx tsc --init`で作成できる
  - 型定義ファイル
    - 型定義ファイルとは主にパッケージを配布するために作られる、アクセス可能な宣言を記述したファイルで、拡張子が`.d.ts`
    - `tsc`に`-d`を指定すると型定義ファイルを出力できる
    - パッケージには型定義ファイルがある場合と、別でインストールする必要がある場合と、ない場合がある
    - `declare`を使うことで、TypeScript に変数や関数、クラスが存在することを宣言できる
    - 型の名前空間を定義するときは`module`ではなく`namespace`を使うことが推奨される
    - 型定義ファイルの先頭で見かける 3 つのスラッシュ`///`ではじめるコメント行をトリプルスラッシュ・ディレクティブという
    - `/// <reference path="..." />`はコンパイラに型定義ファイル間の依存関係を宣言でき、path で指定された型定義ファイルを追加でコンパイル時に読み込むように指示を与える参照ディレクティブ
    - `/// <reference types="..." />`は npm パッケージへの依存関係を宣言できる型ディレクティブ
  - Advanced Topics
    - `tsconfig.json`で`"declaration": true`とするとコンパイルで出力した js ファイルと同じディレクトリに同名で拡張子が d.ts のファイル（型情報のファイル）も出力される
    - sourceMap とは AltJS がコンパイルされた JavaScript との行を一致させるもの
    - フロントとバックのどちらも TypeScript で書くことを Univasal JS という
    - Dual Package は CommonJS 用と ESModule 用の JavaScript を出力すること
    - Tree Tree Shaking とは使われていないクラス、関数を含めないことで、モジュールバンドラーによって 1 つにまとめられた js ファイルの容量を削減する機能の 1 つ
    - Generator は反復可能(`Iterable<T>`)な反復子(`Iterator<T>`)であるインターフェース`IterableIterator<T>`を実装したクラスのオブジェクトのこと
    - 現在でも大量のデータを取得したいときに一度ではなく、小出しに取得したいときに Generator は使い道がある
    - getter/setter を呼ぶ場合は`()`は不要

- 5 章 Tips
  - オブジェクトを浅くコピーする
    - 浅いコピーとはオブジェクトが入れ子構造になっていても第一階層のみをコピーすることで、スプレッド構文を使う
    - 浅いコピーはオリジナルとの厳密比較では`false`を返す
    - 浅いコピーでの第二階層以降は参照になる
    - 深いコピーはメモリを消費する
  - オブジェクトをマージする
    - オブジェクトのマージは、マージしたいオブジェクトをスプレッド構文で並べる
    - 同名のキーがある場合、必ず最後に書かれているものが優先される
  - オブジェクトのサブセットを得る
    - サブセットとはあるオブジェクトの一部分を切り取ったもの
    - サブセットを作るには、即時関数と分割代入と shorthand property name を合わせて使う方法と、lodash.pick/lodash.omit を使う方法の２種類ある
    - lodash はさまざまな便利関数を提供するライブラリ
  - オブジェクトで受け、オブジェクトを返す
    - オブジェクト 1 つを引数で受け取り、戻り値もオブジェクト 1 つとする考え方を RORO（Receive an Object, Return an object）という
    - 引数が増えて順番を機にする必要がある場合に RORO が役立つ
  - コンパニオンオブジェクトパターン
    - コンパニオンオブジェクトは値と型に同名を与えてその両方を区別なく使うテクニック
  - オブジェクトから型を生成する
    - オブジェクトから型を生成するには`typeof`を使う
    - プロパティを定数値で取得したい場合はオブジェクトに`as const`をつける
  - オブジェクトからキーの型を生成する
    - `keyof`をオブジェクトの型に使うと、そのオブジェクトのキーをユニオン型にして返す
  - 配列から型を生成する
    - 配列から型を生成するには`typeof`と`as const`とインデックスを使う

## わからなかったこと

- インデックス型
- 配列の共変性
- タプル型と配列の型の違い
- 判別可能なユニオン型
- 型のメンタルモデル
- `never`型の網羅性チェック
- this 引数
- 型ガード関数
- アサーション関数
- オーバーロード関数
- fluent interface
- 公称型クラス
- zod
- ジェネレータ
- 型定義ファイルの`declare`
- keyof
- Mapped Types
- インデックスアクセス型
- Confitional Types
- ユニオン分配
- オブジェクトからキーの型を生成する
- オブジェクトからプロパティの型を生成する
- 配列から型を生成する
- 配列から全要素の型を生成する

## 次やること

- udemy React 完全入門ガイド
- Jest 公式ドキュメント

## 感想

for-of とか in とか使い方いっつも忘れる。紛らわしい。

サバイバル TypeScript で TypeScript の学習だけじゃなく、JavaScript の復習もできてよかった。

でも型の再利用の部分とかわけわからんかった。

次は後回しにしてた udemyReact 完全入門ガイドと、Jest の公式ドキュメントと Next.js をやる。それ終わったらネットワーク・AWS・Terraform をがっつりやってインプットをとりあえず終了。
そのあとはアプリを作りながら、SQL、コンピュータ基礎、アルゴリズムとデータ構造、NoSQL、アジャイル開発、デザインパターンのインプットを進める。
