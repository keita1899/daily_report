# 8/20

## 取り組んだこと
- udemy React完全入門ガイド
  - 14
  - 15
  - 16
  - 21

## 学んだこと
### udemy React完全入門ガイド
- 14章 クラスコンポーネント
  - 関数コンポーネント以前はクラスコンポーネントを使っていた
  - Reactの16.8からHooksが追加されたので関数コンポーネントが使われるようになった
  - クラスコンポーネントの問題点
    - ロジックとビューの分離が難しい
    - ステートの管理が複雑になるとロジックや副作用の整理が難しい
    - `this`や`bind`を使う必要がある
  - クラスコンポーネントは`Component`をインポートして継承して作る
  - JSXは`render()`の`return`に記述する
  - クラスコンポーネントはstrictモードなので、メソッドをそのまま`this.method`で呼び出すと、メソッド内の`this`は`undefined`になる
  - クラスコンポーネントの`this`の挙動を解決するには`bind`を使って`this`をクラス自身に束縛する（コンストラクタ内で実行する）
  - コンポーネントにはMounting、Updating、Unmountingの3つのライフサイクルがある
  - それぞれのライフサイクルで実行できるライフサイクルメソッドが存在する
  - 関数コンポーネントではライフサイクルは`useEffect`で実現する
  - コンポーネントが初回にマウントされた時 componentDidMount = `useEffect(.., [])`
  - stateが更新された時 componentDidUpdate = `useEffect(.., [val])`
  - コンポーネントが消滅する時 componentWillUnmount = `useEffect(() => {return () => {}}, [])`
  - `ErrorBounday`で囲むと全体のエラーを表示せずに、エラー時のUIを表示できる
  - `ErrorBounday`はクラスコンポーネントでしか実装できない
- 15章 パフォーマンスの最適化
  - Reactで画面を更新する流れ
    1. レンダリングがトリガーされる
    2. コンポーネントを実行してレンダリングする
    3. DOMへの更新を行う
  - 初回のレンダリングはルートコンポーネントをHTMLにマウントした時
  - stateが更新された時に再レンダリングが走る
  - 現在地と同じ値で更新を行うとReactは子のレンダーや副作用の実行を回避して処理を終了する
  - 再レンダリングはそのコンポーネントの子コンポーネントもすべて行われる
  - stateの変化は内部では`Object.is`で検知する
  - StrictModeだとReactがレンダリングを実行してバグがないか確認するので、開発環境では余分にレンダリングが実行される（本番では実行されない）
  - `StrictMode`はルートコンポーネントを囲むのが一般的
  - `React.memo`は囲んだコンポーネントが受け取るpropsが更新されない限り、再レンダリングが実行されなくなる
  - 子コンポーネントのpropsで関数を受け取る場合、親コンポーネントで渡したい関数を`useCallback`で囲むと、再レンダリングが発生しても再定義されず同じ関数が渡されることになる
  - `useCallback`では第二引数で依存配列を指定する必要がある
  - `useCallback`内の関数でstateを更新する場合は依存配列にそのstateを指定する
  - `useMemo`はコールバック関数でreturnするあらゆる値をメモ化できる（キャッシュする）
  - `useMemo`自体の判定処理もコストがかかる
  - `startTransition`は処理を遅延しているだけなので、メモ化を行なってもパフォーマンスが解決しない場合に検討すべき
  - React18で導入されたConcurrent Modeは処理の優先順位付けを行なってより快適でレスポンシブな画面を作成する機能
- 16章 Rest APIを使ったサーバーとの通信
  - Reactでサーバーと通信を行う場合は、Reactのコードでサーバーにリクエストを送り、サーバーがJSONでレスポンスを送信するのが一般的
  - REST APIはサーバーへのリクエスト方式のこと
  - REST APIを使わない場合は`/create-todo`や`/delete-todo`のように処理ごとにURLのパスを設ける
  - REST APIの場合はリソースごとにURLを作り、HTTPメソッドで処理を分ける
  - JSONはJavaScriptのオブジェクトのようなデータ定義言語
  - `.json`はコメントをかけないが、`.jsonc`とするとコメントを書ける
  - JavaScriptのオブジェクトをJSONに変換するには`JSON.stringify`を使う
  - JSONをJavaScriptが認識できる形に変換するには`JSON.parse`を使う（サーバーからのレスポンスなど）
  - JSON serverは開発環境用のAPIのモックを作成できるnode.jsのライブラリ
  - `useEffect`のコールバック関数に`async`をつけるとエラーが出るので、非同期処理の関数を作る
  - `axios`を使うとJSONを内部でJavaScriptのオブジェクトに変換してくれる
  - 非同期で取得したデータはstateに格納する
  - `useEffect`でstateを更新する時に第二引数に空の配列を渡さないと無限ループになる
  - ダイナミックインポートは`import()`を使ったインポートの方法で、モジュールが必要になったときに読み込めるようになる
  - `import()`はPromiseを返す
  - Reactでダイナミックインポートを使う時は`lazy()`を使って、コールバック関数にコンポーネントを読み込む`import()`を使う
- 21章 TypeScript
  - 基本的には関数内で使うオブジェクトは型推論を使い、外部から渡されるオブジェクトは型を定義すべき
  - TypeScriptでは引数の個数が合わないとエラーになる
  - 関数コンポーネントの型定義では`React.FC`を使う
  - `children`の型は`React.ReactNode`を指定する
  - TypeScriptではクラスのメンバーを定義する必要がある
  - Eventの型にはイベントの種類によって変わる
  - `onClick`などに直接関数を記述した場合は自動で型が指定される
  - 型情報だけをインポートする時は`import type`を使える

## わからなかったこと
- レンダリングの最適化は全てのコンポーネントや関数で行うべきか否か
- ダイナミックインポートの使い道

## 次やること
- udemy React完全入門ガイド
  - 11
  - 12
  - 13
  - 15

## 感想
レンダリングの最適化でどれぐらいパフォーマンスに影響あるか知りたい。