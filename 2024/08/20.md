# 8/20

## 取り組んだこと

- udemy React 完全入門ガイド
  - 14
  - 15
  - 16
  - 21

## 学んだこと

### udemy React 完全入門ガイド

- 14 章 クラスコンポーネント
  - 関数コンポーネント以前はクラスコンポーネントを使っていた
  - React の 16.8 から Hooks が追加されたので関数コンポーネントが使われるようになった
  - クラスコンポーネントの問題点
    - ロジックとビューの分離が難しい
    - ステートの管理が複雑になるとロジックや副作用の整理が難しい
    - `this`や`bind`を使う必要がある
  - クラスコンポーネントは`Component`をインポートして継承して作る
  - JSX は`render()`の`return`に記述する
  - クラスコンポーネントは strict モードなので、メソッドをそのまま`this.method`で呼び出すと、メソッド内の`this`は`undefined`になる
  - クラスコンポーネントの`this`の挙動を解決するには`bind`を使って`this`をクラス自身に束縛する（コンストラクタ内で実行する）
  - コンポーネントには Mounting、Updating、Unmounting の 3 つのライフサイクルがある
  - それぞれのライフサイクルで実行できるライフサイクルメソッドが存在する
  - 関数コンポーネントではライフサイクルは`useEffect`で実現する
  - コンポーネントが初回にマウントされた時 componentDidMount = `useEffect(.., [])`
  - state が更新された時 componentDidUpdate = `useEffect(.., [val])`
  - コンポーネントが消滅する時 componentWillUnmount = `useEffect(() => {return () => {}}, [])`
  - `ErrorBounday`で囲むと全体のエラーを表示せずに、エラー時の UI を表示できる
  - `ErrorBounday`はクラスコンポーネントでしか実装できない
- 15 章 パフォーマンスの最適化
  - React で画面を更新する流れ
    1. レンダリングがトリガーされる
    2. コンポーネントを実行してレンダリングする
    3. DOM への更新を行う
  - 初回のレンダリングはルートコンポーネントを HTML にマウントした時
  - state が更新された時に再レンダリングが走る
  - 現在地と同じ値で更新を行うと React は子のレンダーや副作用の実行を回避して処理を終了する
  - 再レンダリングはそのコンポーネントの子コンポーネントもすべて行われる
  - state の変化は内部では`Object.is`で検知する
  - StrictMode だと React がレンダリングを実行してバグがないか確認するので、開発環境では余分にレンダリングが実行される（本番では実行されない）
  - `StrictMode`はルートコンポーネントを囲むのが一般的
  - `React.memo`は囲んだコンポーネントが受け取る props が更新されない限り、再レンダリングが実行されなくなる
  - 子コンポーネントの props で関数を受け取る場合、親コンポーネントで渡したい関数を`useCallback`で囲むと、再レンダリングが発生しても再定義されず同じ関数が渡されることになる
  - `useCallback`では第二引数で依存配列を指定する必要がある
  - `useCallback`内の関数で state を更新する場合は依存配列にその state を指定する
  - `useMemo`はコールバック関数で return するあらゆる値をメモ化できる（キャッシュする）
  - `useMemo`自体の判定処理もコストがかかる
  - `startTransition`は処理を遅延しているだけなので、メモ化を行なってもパフォーマンスが解決しない場合に検討すべき
  - React18 で導入された Concurrent Mode は処理の優先順位付けを行なってより快適でレスポンシブな画面を作成する機能
- 16 章 Rest API を使ったサーバーとの通信
  - React でサーバーと通信を行う場合は、React のコードでサーバーにリクエストを送り、サーバーが JSON でレスポンスを送信するのが一般的
  - REST API はサーバーへのリクエスト方式のこと
  - REST API を使わない場合は`/create-todo`や`/delete-todo`のように処理ごとに URL のパスを設ける
  - REST API の場合はリソースごとに URL を作り、HTTP メソッドで処理を分ける
  - JSON は JavaScript のオブジェクトのようなデータ定義言語
  - `.json`はコメントをかけないが、`.jsonc`とするとコメントを書ける
  - JavaScript のオブジェクトを JSON に変換するには`JSON.stringify`を使う
  - JSON を JavaScript が認識できる形に変換するには`JSON.parse`を使う（サーバーからのレスポンスなど）
  - JSON server は開発環境用の API のモックを作成できる node.js のライブラリ
  - `useEffect`のコールバック関数に`async`をつけるとエラーが出るので、非同期処理の関数を作る
  - `axios`を使うと JSON を内部で JavaScript のオブジェクトに変換してくれる
  - 非同期で取得したデータは state に格納する
  - `useEffect`で state を更新する時に第二引数に空の配列を渡さないと無限ループになる
  - ダイナミックインポートは`import()`を使ったインポートの方法で、モジュールが必要になったときに読み込めるようになる
  - `import()`は Promise を返す
  - React でダイナミックインポートを使う時は`lazy()`を使って、コールバック関数にコンポーネントを読み込む`import()`を使う
- 21 章 TypeScript
  - 基本的には関数内で使うオブジェクトは型推論を使い、外部から渡されるオブジェクトは型を定義すべき
  - TypeScript では引数の個数が合わないとエラーになる
  - 関数コンポーネントの型定義では`React.FC`を使う
  - `children`の型は`React.ReactNode`を指定する
  - TypeScript ではクラスのメンバーを定義する必要がある
  - Event の型にはイベントの種類によって変わる
  - `onClick`などに直接関数を記述した場合は自動で型が指定される
  - 型情報だけをインポートする時は`import type`を使える

## わからなかったこと

- レンダリングの最適化は全てのコンポーネントや関数で行うべきか否か
- ダイナミックインポートの使い道

## 次やること

- udemy React 完全入門ガイド
  - 11
  - 12
  - 13
  - 15

## 感想

レンダリングの最適化でどれぐらいパフォーマンスに影響あるか知りたい。
