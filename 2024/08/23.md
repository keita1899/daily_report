# 8/23

## 取り組んだこと

- TypeScript と React/Next.js でつくる実践 Web アプリケーション開発
  - 1
  - 2
  - 3

## 学んだこと

### TypeScript と React/Next.js でつくる実践 Web アプリケーション開発

- 1 章 Next.js と TypeScript によるモダン開発
  - Next.js は React の機能をサーバーサイドでレンダリングされるアプリにも拡張できる
  - フロントエンド開発の変遷
    1. JavaScript はブラウザ上で動くスクリプト言語として登場
    2. ECMA による JavaScript の標準化への動き
    3. JavaScript は補助的に使われる程度
    4. Google Maps の Ajax 機能をきっかけに再注目
    5. Google Chrome と V8 の誕生により、実行速度が上がる
    6. ブラウザの挙動の違いを吸収できる jQuery が流行る
    7. SPA の登場により、フロントとサーバーの開発の分離が可能に
    8. MVC/MVMM フレームワークの登場
    9. React の登場
    10. モダンフロント開発に必要な機能を一通り備えた Next.js の登場
  - 双方向データバインディングはコードを簡潔化できるが、多用するとどこの変更がどこに影響を与えるかがわかりづらい
  - Flux はデータの流れを単一方向に限定し、状態管理をわかりやすくできる
  - Redux は Flux を発展的に継承したライブラリ
  - Deno は JavaScript/TypeScript の新しいランタイム
  - ビルドシステムとはモジュールの依存を解決し、実行可能な JavaScript の形式に変換する仕組み
  - Grunt や gulp などのタスクランナーは学習コストがかかったため、npm のスクリプトが使われるようになった
  - クライアントサイドレンダリングの初期表示が遅い問題を解決するのが SSR や SSG
  - SSR はサーバーサイドレンダリングの略で、サーバーサイドでリクエストに応じてページを生成し、HTML を返すこと
  - SSG は Static Site Generation の略で、事前に静的ファイルとして生成し、デプロイする仕組み
  - コンポーネント指向は、再利用可能なコンポーネントの組み合わせによって UI を構築する設計手法
  - コンポーネントの見た目を変えるには、外部から必要な値を受け入れるか、内部の状態を変化させる
  - state が影響を与えるのは必ずそのコンポーネント自身か子コンポーネント
  - props のバケツリレーを解決するには Flux または Context を使う
  - 従来の Web サイトのデザインはページ単位だったが非効率
  - Atomic Design は UI はページ単位ではなく、機能とコンポーネントで捉えるべきであるという考え方
  - Storybook はコンポーネントをカタログ化して、管理できる開発ツール
  - Storybook によって他の開発者やデザイナーとの共通認識をとれたり、コンポーネントに必要な値や動的な変更を確認できたりする
  - Storybook と Atomic Design は相性が良い
- 2 章 TypeScript の基礎
  - JavaScript は後方互換性を重視する言語で、仕様の抜本的な変更は難しいので、AltJS で回避する
  - 実際の Web アプリでは Next.js などのフレームワークがコンパイルを実行するので、`tsc`コマンドを使うことはない
  - TypeScript を使わないと、UI 上のフォームや API 経由で受け取った値が正しいものか判定されないのでエラーが起きる可能性が高い
  - オブジェクトのプロパティに`?`をつけると省略可能なプロパティとして定義できる
  - オブジェクト型は記述が長くなるので型エイリアスを使うことが多い
  - TypeScript が具体的な型を知ることができないケース（DOM など）では`as`を用いて型アサーションを使う
  - インデックス型を使うとオブジェクトのキー名を明記せずに型エイリアスを定義できる
  - インタフェースは拡張可能で、型エイリアスは同名の型定義ができない
  - インタフェースはクラスやデータの一側面を定義した型で、型エイリアスはオブジェクトの型そのものを表すもの
  - オブジェクトそのものではなく、クラスやオブジェクトの一部のプロパティや関数含む一部の振る舞いを定義するものであればインタフェースが適している
  - インタフェースに対して`implements`を使うことでクラスに対する実装を強制する
  - Union 型は`|`を使って指定したいずれかの型に当てはまればいい
  - 型エイリアスを Union 型で組み合わせることもできる
  - Intersection 型は`&`を使って複数の型をマージして 1 つとなった型
  - Optional Chaining はネストされたオブジェクトのプロパティが存在するかどうかの条件分岐を簡単に記述できる機能
  - プロパティアクセス時に`?`を使うことで、null か undefined になりうるオブジェクトに対して安全に処理を記述できる
  - `--strictNullChecks`を指定してコンパイルすると、null の可能性のあるオブジェクトへのアクセスはエラーになる（実行時にエラーが起きる可能性はある）
  - null の可能性のある変数に`!`をつけるとコンパイルエラーを抑制できる
  - 型ガードは if 文や switch 文で型のチェックを行ったときに、条件分岐ブロック以降は変数の型を絞り込む推論が行われるもの
  - 型ガードを使うことで、複数の型に対応しているときに、型を安全に判別し適切な処理を行える
  - never の使い方として、if 文や switch 文で TypeScript の型の条件分岐に漏れがないことを保証するケースがある
  - 型に対して keyof オペレーターを使うと、その型が持つ各プロパティのリテラル型の Union 型を返せる
  - インデックス型を使うとオブジェクトのプロパティが可変の時にまとめて型を定義できる
  - unknown 型を使うと代入された値は関数やプロパティにアクセスできない
  - Prettier は`.prettierrc`ファイルで設定を行う
  - ESLint は`.eslintrc.js`ファイルで設定を行う
  - コンパイラが行う処理
    1. Scanner が TypeScript のソースコードを読み取り、それぞれの文法の要素を位置の情報を持つトークンに変換する
    2. Parser がトークンを受け取り、抽象構文木に変換する
    3. Binder が抽象構文木を元に型チェックの基本となる Symbol を作成する
    4. Checker が型チェックを実行する
    5. Emitter が抽象構文木と Checker の結果を元に TypeScript から JavaScript に変換し出力する
  - TypeScript の ES モジュールには型のみを import する import type がある
- 3 章 React/Next.js の基礎
  - create react app で TypeScript を使う場合は`--template typescript`を指定する
  - `npx`は npm に付属するコマンド実行用のユーティリティコマンドで、コマンドがローカルにインストールされている場所を探して実行し、ローカルになければリモートから取得して実行する
  - `npm run build`は`build/`に出力する
  - JSX はブラウザが解釈できないので Webpack によって JavaScript のコードに変換される
  - コンポーネントの頭文字を大文字にしないとコンポーネントとして認識されない
  - Next.js ではビルドツールとして主に SWC が使われる
  - 関数コンポーネントは任意のオブジェクトを props として引数に受け取り、JSX.Element 型の値を返す
  - children の型は`React.ReactNode`を指定する
  - props に型注釈をせずにコンポーネントに`FC`や`VFC`を指定することもできるが、現在は props に型を指定するのが一般的
  - `VFC`は children を取らないコンポーネントに指定する型で、React.18 からは非推奨
  - `FC`は chidlren を取るコンポーネントに指定する型で、現在は使われない傾向にある
  - ログインユーザーの情報などは props より`context`の方が適している
  - Context ではデータを渡す`Provider`とデータを受け取る`Consumer`の 2 つのコンポーネントを使う
  - React Hooks によってコンポーネント内の状態とロジックを分離できるようになった
  - `useState`の更新関数を呼ぶ時には引数に値を渡す方法と関数を渡す方法の２種類ある
  - 値を渡すとその値が次の状態になり、関数を渡すと戻り値が次の状態になる
  - `useReducer`も状態を扱うためのフックで、複雑な状態遷移をシンプルに書くことができ、配列やオブジェクトなどの複数のデータをまとめたものを状態として扱う場合に使われることが多い
  - `useReducer`を使うと`useState`に比べどのように状態を更新するかが分かりやすく、状態を更新するロジックをコンポーネント外の関数に切り出しているのでテストがしやすいメリットがある
  - 関数やオブジェクト、配列はレンダリングのたびに新しいものが作られるため、メモ化したコンポーネントに関数やオブジェクトを渡すと親コンポーネントのレンダリングによって再レンダリングが発生する
  - `useCallback`と`useMemo`はコンポーネントの描画時に依存配列の値を比較して、前の値を異なる場合は新しい関数、値を返し、同じ場合はメモに保存する
  - 副作用とは手動で DOM を変更したり、データを取得したり、ログを出力するなどの、コンポーネントのレンダリングとは直接関係のない処理のこと
  - `useEffect`を使うと、props や state が更新されて再レンダリングされた後に処理が実行される
  - `useEffect`は DOM が更新されて描画された後に実行されるが、`useLayoutEffect`は DOM が更新された後に実際に画面に描画される前に実行されるフック
  - `useLayoutEffect`は同期的に実行されるため、重い処理だと遅延が発生する可能性がある
  - `useContext`は`Context`から値を参照するフック
  - コンポーネントのトップレベル以外でフックを呼び出すとビルドエラーまたは実行時エラーになる
  - フックを使用する関数を定義したものをカスタムフックといい、関数コンポーネントのトップレベルで呼び出すことができる
  - カスタムフックを使うことで、複数のフックを使ったロジックをまとめることができ、他のコンポーネントでも共有できるようになる
  - カスタムフックの名前は監修的に`use`から始める
  - `useDebugValue`はデバッグように使われるフック
  - create next app で TypeScript を使うときは`--ts`を指定する
  - next.js で`npm run build`を実行すると、`.next`以下にビルドしたプロジェクトのコードを保存し、`npm run start`を実行するとビルドしたデータを元にサーバーを立ち上げる
  - Next.js ではページごとにレンダリング手法を切り替えることができ、SSR、CSR、SSR、ISR の 4 つのレンダリング手法がある
  - SSG は静的サイト生成のことで、ビルド時に`getStaticProps`という関数が呼ばれ、その関数の中で API コールなどを行い、必要な props を返して描画し、静的ファイルとして生成する
  - SSG はアクセス時は静的ファイルをクライアントに渡すだけなので初期描画が高速だが、ビルド時のみデータ取得を行うので古いデータが表示される可能性もある
  - SSG は変更が少ないブログの記事などに向いている
  - CSR はクライアントサイドレンダリングの略で、ビルド時にデータ取得を行わず、ページを描画して保存する、もともとの React アプリの流れに近い描画方法
  - CSR は初期描画が重要で無いリアルタイム性が必要なページに向いているが、必要なデータを後から取得するので SEO に向いていない
  - CSR は基本的に他のレンダリング手法と組み合わせて使う
  - SSR はサーバーサイドレンダリングの略で、ページのアクセスがあるたびにサーバーで`getServerSideProps`を実行し、その結果の props を元にページをサーバー側で描画してクライアントへ渡す方法
  - SSR は常に最新のデータを描画でき、SEO にも有効であるが、サーバー側の負担があるため他のレンダリング手法よりパフォーマンスは良くない傾向にある
  - ISR はインクリメンタル静的再生成のことで、SSG と SSR の中間のようなレンダリング手法
  - ISR は事前にページを生成して配信しつつ、アクセスに応じてページを再度生成して新しいページを配信できる
  - ISR ではクライアントに渡すデータの有効期限を設定でき、期限が切れた状態でアクセスされた場合にバックグラウンドで再度`getStaticProps`で実行と描画を行い、サーバーに保存されているデータを更新する
  - Next.js では`pages`ディレクトリ以下の 1 つのファイルが 1 つのページに対応する
  - Next.js では実装する関数や関数の戻り値のよって pages のレンダリング手法が切り替わる
    - `getStaticProps` - SSG
    - `getServerSideProps` - SSR
    - `revalidate`を返す`getStaticProps` - ISR
    - 上記以外の任意の関数 - CSR
  - `NextPage`は pages のための型
  - SSG で使う`getStaticProps`はエクスポートする必要があり、async で非同期関数として定義する必要がある
  - `getStaticProps`の引数にはビルド時に使用されるデータが格納された`context`が渡される
  - `getStaticPaths`は`getStaticProps`の実行前に呼ばれる関数で、生成したいページのパスパラメータの組み合わせ（`paths`）と`fallback`を返す
  - `paths`は配列の要素 1 つが 1 つのページに対応する
  - `fallback`は生成するページが存在しない場合の処理を記述する
  - `getStaticPaths`によって生成されたパスそれぞれに対して`getStaticProps`が呼ばれる
  - パスパラメータを取得する場合は`context.params`で取得する
  - ISR を実装するには`getStaticProps`でページの有効期間を秒数で設定する`revalidate`を返す
  - Next.js には`next/link`や`next/image`などの組み込みコンポーネントや機能がある
  - `Link`コンポーネントを使うと通常の画面遷移と異なり、ページに必要なデータは非同期で取得して、クライアントサイドで新しいページを描画するので、高速なページ遷移が可能
  - `router`オブジェクトにはリロードを行う`reload`や前のページに戻る`back`などのメソッドがある
  - `Image`コンポーネントを使うと、画像を読み込む際にサーバーサイドで画像の最適化を行う
  - `Image`は`width`と`height`を渡さないとエラーになる
  - Next.js では画像は`public/images`ディレクトリに配置する
  - `pages/api`以下にファイルを置くことで、簡易的な JSON ベースの API を実装できる
  - 簡易的な API は`getStaticPaths`や`getStaticProps`から呼ぶことはできない
  - Next.js ではビルトインで環境変数のための`.env`ファイルを処理できる
  - `.env.local`は API キーなどの公開したくない値を保存するために使用するファイルで、`.gitignore`に追加されることを意図している
  - 環境変数はサーバーサイドで参照でき、`NEXT_PUBLIC_`をつけることでクライアントサイドでもアクセスできる
  - React は基本的に常に最新のリリースが安定版で、LTS のような仕組みはない
  - React や Next.js は定期的にバージョンアップすべき

## わからなかったこと

- 型アサーション
- 型ガード

## 次やること

- TypeScript と React/Next.js でつくる実践 Web アプリケーション開発
  - 4
  - 5
  - 6
  - 7

## 感想

Union 型と Intersection 型あたりが毎回ごっちゃになる。

ここ最近で TypeScript の基礎はなんとなく理解できたからアウトプットしていきたい。でも React だとクラスを使うことってなさそうだから、インタフェースとか使うことあるんかな。あと応用的な使い方を React でどんなときに使うか知りたい。

電子書籍だとコード読みにくい。
