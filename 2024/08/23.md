# 8/23

## 取り組んだこと
- TypeScriptとReact/Next.jsでつくる実践Webアプリケーション開発
  - 1
  - 2
  - 3

## 学んだこと
### TypeScriptとReact/Next.jsでつくる実践Webアプリケーション開発
- 1章 Next.jsとTypeScriptによるモダン開発
  - Next.jsはReactの機能をサーバーサイドでレンダリングされるアプリにも拡張できる
  - フロントエンド開発の変遷
    1. JavaScriptはブラウザ上で動くスクリプト言語として登場
    2. ECMAによるJavaScriptの標準化への動き
    3. JavaScriptは補助的に使われる程度
    4. Google MapsのAjax機能をきっかけに再注目
    5. Google ChromeとV8の誕生により、実行速度が上がる
    6. ブラウザの挙動の違いを吸収できるjQueryが流行る
    7. SPAの登場により、フロントとサーバーの開発の分離が可能に
    8. MVC/MVMMフレームワークの登場
    9. Reactの登場
    10. モダンフロント開発に必要な機能を一通り備えたNext.jsの登場
  - 双方向データバインディングはコードを簡潔化できるが、多用するとどこの変更がどこに影響を与えるかがわかりづらい
  - Fluxはデータの流れを単一方向に限定し、状態管理をわかりやすくできる
  - ReduxはFluxを発展的に継承したライブラリ
  - DenoはJavaScript/TypeScriptの新しいランタイム
  - ビルドシステムとはモジュールの依存を解決し、実行可能なJavaScriptの形式に変換する仕組み
  - Gruntやgulpなどのタスクランナーは学習コストがかかったため、npmのスクリプトが使われるようになった
  - クライアントサイドレンダリングの初期表示が遅い問題を解決するのがSSRやSSG
  - SSRはサーバーサイドレンダリングの略で、サーバーサイドでリクエストに応じてページを生成し、HTMLを返すこと
  - SSGはStatic Site Generationの略で、事前に静的ファイルとして生成し、デプロイする仕組み
  - コンポーネント指向は、再利用可能なコンポーネントの組み合わせによってUIを構築する設計手法
  - コンポーネントの見た目を変えるには、外部から必要な値を受け入れるか、内部の状態を変化させる
  - stateが影響を与えるのは必ずそのコンポーネント自身か子コンポーネント
  - propsのバケツリレーを解決するにはFluxまたはContextを使う
  - 従来のWebサイトのデザインはページ単位だったが非効率
  - Atomic DesignはUIはページ単位ではなく、機能とコンポーネントで捉えるべきであるという考え方
  - Storybookはコンポーネントをカタログ化して、管理できる開発ツール
  - Storybookによって他の開発者やデザイナーとの共通認識をとれたり、コンポーネントに必要な値や動的な変更を確認できたりする
  - StorybookとAtomic Designは相性が良い
- 2章 TypeScriptの基礎
  - JavaScriptは後方互換性を重視する言語で、仕様の抜本的な変更は難しいので、AltJSで回避する
  - 実際のWebアプリではNext.jsなどのフレームワークがコンパイルを実行するので、`tsc`コマンドを使うことはない
  - TypeScriptを使わないと、UI上のフォームやAPI経由で受け取った値が正しいものか判定されないのでエラーが起きる可能性が高い
  - オブジェクトのプロパティに`?`をつけると省略可能なプロパティとして定義できる
  - オブジェクト型は記述が長くなるので型エイリアスを使うことが多い
  - TypeScriptが具体的な型を知ることができないケース（DOMなど）では`as`を用いて型アサーションを使う
  - インデックス型を使うとオブジェクトのキー名を明記せずに型エイリアスを定義できる
  - インタフェースは拡張可能で、型エイリアスは同名の型定義ができない
  - インタフェースはクラスやデータの一側面を定義した型で、型エイリアスはオブジェクトの型そのものを表すもの
  - オブジェクトそのものではなく、クラスやオブジェクトの一部のプロパティや関数含む一部の振る舞いを定義するものであればインタフェースが適している
  - インタフェースに対して`implements`を使うことでクラスに対する実装を強制する
  - Union型は`|`を使って指定したいずれかの型に当てはまればいい
  - 型エイリアスをUnion型で組み合わせることもできる
  - Intersection型は`&`を使って複数の型をマージして1つとなった型
  - Optional Chainingはネストされたオブジェクトのプロパティが存在するかどうかの条件分岐を簡単に記述できる機能
  - プロパティアクセス時に`?`を使うことで、nullかundefinedになりうるオブジェクトに対して安全に処理を記述できる
  - `--strictNullChecks`を指定してコンパイルすると、nullの可能性のあるオブジェクトへのアクセスはエラーになる（実行時にエラーが起きる可能性はある）
  - nullの可能性のある変数に`!`をつけるとコンパイルエラーを抑制できる
  - 型ガードはif文やswitch文で型のチェックを行ったときに、条件分岐ブロック以降は変数の型を絞り込む推論が行われるもの
  - 型ガードを使うことで、複数の型に対応しているときに、型を安全に判別し適切な処理を行える
  - neverの使い方として、if文やswitch文でTypeScriptの型の条件分岐に漏れがないことを保証するケースがある
  - 型に対してkeyofオペレーターを使うと、その型が持つ各プロパティのリテラル型のUnion型を返せる
  - インデックス型を使うとオブジェクトのプロパティが可変の時にまとめて型を定義できる
  - unknown型を使うと代入された値は関数やプロパティにアクセスできない
  - Prettierは`.prettierrc`ファイルで設定を行う
  - ESLintは`.eslintrc.js`ファイルで設定を行う
  - コンパイラが行う処理
    1. ScannerがTypeScriptのソースコードを読み取り、それぞれの文法の要素を位置の情報を持つトークンに変換する
    2. Parserがトークンを受け取り、抽象構文木に変換する
    3. Binderが抽象構文木を元に型チェックの基本となるSymbolを作成する
    4. Checkerが型チェックを実行する
    5. Emitterが抽象構文木とCheckerの結果を元にTypeScriptからJavaScriptに変換し出力する
  - TypeScriptのESモジュールには型のみをimportするimport typeがある
- 3章 React/Next.jsの基礎
  - create react appでTypeScriptを使う場合は`--template typescript`を指定する
  - `npx`はnpmに付属するコマンド実行用のユーティリティコマンドで、コマンドがローカルにインストールされている場所を探して実行し、ローカルになければリモートから取得して実行する
  - `npm run build`は`build/`に出力する
  - JSXはブラウザが解釈できないのでWebpackによってJavaScriptのコードに変換される
  - コンポーネントの頭文字を大文字にしないとコンポーネントとして認識されない
  - Next.jsではビルドツールとして主にSWCが使われる
  - 関数コンポーネントは任意のオブジェクトをpropsとして引数に受け取り、JSX.Element型の値を返す
  - childrenの型は`React.ReactNode`を指定する
  - propsに型注釈をせずにコンポーネントに`FC`や`VFC`を指定することもできるが、現在はpropsに型を指定するのが一般的
  - `VFC`はchildrenを取らないコンポーネントに指定する型で、React.18からは非推奨
  - `FC`はchidlrenを取るコンポーネントに指定する型で、現在は使われない傾向にある
  - ログインユーザーの情報などはpropsより`context`の方が適している
  - Contextではデータを渡す`Provider`とデータを受け取る`Consumer`の2つのコンポーネントを使う
  - React Hooksによってコンポーネント内の状態とロジックを分離できるようになった
  - `useState`の更新関数を呼ぶ時には引数に値を渡す方法と関数を渡す方法の２種類ある
  - 値を渡すとその値が次の状態になり、関数を渡すと戻り値が次の状態になる
  - `useReducer`も状態を扱うためのフックで、複雑な状態遷移をシンプルに書くことができ、配列やオブジェクトなどの複数のデータをまとめたものを状態として扱う場合に使われることが多い
  - `useReducer`を使うと`useState`に比べどのように状態を更新するかが分かりやすく、状態を更新するロジックをコンポーネント外の関数に切り出しているのでテストがしやすいメリットがある
  - 関数やオブジェクト、配列はレンダリングのたびに新しいものが作られるため、メモ化したコンポーネントに関数やオブジェクトを渡すと親コンポーネントのレンダリングによって再レンダリングが発生する
  - `useCallback`と`useMemo`はコンポーネントの描画時に依存配列の値を比較して、前の値を異なる場合は新しい関数、値を返し、同じ場合はメモに保存する
  - 副作用とは手動でDOMを変更したり、データを取得したり、ログを出力するなどの、コンポーネントのレンダリングとは直接関係のない処理のこと
  - `useEffect`を使うと、propsやstateが更新されて再レンダリングされた後に処理が実行される
  - `useEffect`はDOMが更新されて描画された後に実行されるが、`useLayoutEffect`はDOMが更新された後に実際に画面に描画される前に実行されるフック
  - `useLayoutEffect`は同期的に実行されるため、重い処理だと遅延が発生する可能性がある
  - `useContext`は`Context`から値を参照するフック
  - コンポーネントのトップレベル以外でフックを呼び出すとビルドエラーまたは実行時エラーになる
  - フックを使用する関数を定義したものをカスタムフックといい、関数コンポーネントのトップレベルで呼び出すことができる
  - カスタムフックを使うことで、複数のフックを使ったロジックをまとめることができ、他のコンポーネントでも共有できるようになる
  - カスタムフックの名前は監修的に`use`から始める
  - `useDebugValue`はデバッグように使われるフック
  - create next appでTypeScriptを使うときは`--ts`を指定する
  - next.jsで`npm run build`を実行すると、`.next`以下にビルドしたプロジェクトのコードを保存し、`npm run start`を実行するとビルドしたデータを元にサーバーを立ち上げる
  - Next.jsではページごとにレンダリング手法を切り替えることができ、SSR、CSR、SSR、ISRの4つのレンダリング手法がある
  - SSGは静的サイト生成のことで、ビルド時に`getStaticProps`という関数が呼ばれ、その関数の中でAPIコールなどを行い、必要なpropsを返して描画し、静的ファイルとして生成する
  - SSGはアクセス時は静的ファイルをクライアントに渡すだけなので初期描画が高速だが、ビルド時のみデータ取得を行うので古いデータが表示される可能性もある
  - SSGは変更が少ないブログの記事などに向いている
  - CSRはクライアントサイドレンダリングの略で、ビルド時にデータ取得を行わず、ページを描画して保存する、もともとのReactアプリの流れに近い描画方法
  - CSRは初期描画が重要で無いリアルタイム性が必要なページに向いているが、必要なデータを後から取得するのでSEOに向いていない
  - CSRは基本的に他のレンダリング手法と組み合わせて使う
  - SSRはサーバーサイドレンダリングの略で、ページのアクセスがあるたびにサーバーで`getServerSideProps`を実行し、その結果のpropsを元にページをサーバー側で描画してクライアントへ渡す方法
  - SSRは常に最新のデータを描画でき、SEOにも有効であるが、サーバー側の負担があるため他のレンダリング手法よりパフォーマンスは良くない傾向にある
  - ISRはインクリメンタル静的再生成のことで、SSGとSSRの中間のようなレンダリング手法
  - ISRは事前にページを生成して配信しつつ、アクセスに応じてページを再度生成して新しいページを配信できる
  - ISRではクライアントに渡すデータの有効期限を設定でき、期限が切れた状態でアクセスされた場合にバックグラウンドで再度`getStaticProps`で実行と描画を行い、サーバーに保存されているデータを更新する
  - Next.jsでは`pages`ディレクトリ以下の1つのファイルが1つのページに対応する
  - Next.jsでは実装する関数や関数の戻り値のよってpagesのレンダリング手法が切り替わる
    - `getStaticProps` - SSG
    - `getServerSideProps` - SSR
    - `revalidate`を返す`getStaticProps` - ISR
    - 上記以外の任意の関数 - CSR
  - `NextPage`はpagesのための型
  - SSGで使う`getStaticProps`はエクスポートする必要があり、asyncで非同期関数として定義する必要がある
  - `getStaticProps`の引数にはビルド時に使用されるデータが格納された`context`が渡される
  - `getStaticPaths`は`getStaticProps`の実行前に呼ばれる関数で、生成したいページのパスパラメータの組み合わせ（`paths`）と`fallback`を返す
  - `paths`は配列の要素1つが1つのページに対応する
  - `fallback`は生成するページが存在しない場合の処理を記述する
  - `getStaticPaths`によって生成されたパスそれぞれに対して`getStaticProps`が呼ばれる
  - パスパラメータを取得する場合は`context.params`で取得する
  - ISRを実装するには`getStaticProps`でページの有効期間を秒数で設定する`revalidate`を返す
  - Next.jsには`next/link`や`next/image`などの組み込みコンポーネントや機能がある
  - `Link`コンポーネントを使うと通常の画面遷移と異なり、ページに必要なデータは非同期で取得して、クライアントサイドで新しいページを描画するので、高速なページ遷移が可能
  - `router`オブジェクトにはリロードを行う`reload`や前のページに戻る`back`などのメソッドがある
  - `Image`コンポーネントを使うと、画像を読み込む際にサーバーサイドで画像の最適化を行う
  - `Image`は`width`と`height`を渡さないとエラーになる
  - Next.jsでは画像は`public/images`ディレクトリに配置する
  - `pages/api`以下にファイルを置くことで、簡易的なJSONベースのAPIを実装できる
  - 簡易的なAPIは`getStaticPaths`や`getStaticProps`から呼ぶことはできない
  - Next.jsではビルトインで環境変数のための`.env`ファイルを処理できる
  - `.env.local`はAPIキーなどの公開したくない値を保存するために使用するファイルで、`.gitignore`に追加されることを意図している
  - 環境変数はサーバーサイドで参照でき、`NEXT_PUBLIC_`をつけることでクライアントサイドでもアクセスできる
  - Reactは基本的に常に最新のリリースが安定版で、LTSのような仕組みはない
  - ReactやNext.jsは定期的にバージョンアップすべき

## わからなかったこと
- 型アサーション
- 型ガード

## 次やること
- TypeScriptとReact/Next.jsでつくる実践Webアプリケーション開発
  - 4
  - 5
  - 6
  - 7

## 感想
Union型とIntersection型あたりが毎回ごっちゃになる。

ここ最近でTypeScriptの基礎はなんとなく理解できたからアウトプットしていきたい。でもReactだとクラスを使うことってなさそうだから、インタフェースとか使うことあるんかな。あと応用的な使い方をReactでどんなときに使うか知りたい。

電子書籍だとコード読みにくい。