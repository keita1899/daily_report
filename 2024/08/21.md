# 8/21

## 取り組んだこと
- udemy React完全入門ガイド
  - 11
  - 12
  - 13
  - 20

## 学んだこと
### udemy React完全入門ガイド
- 11章 様々な状態管理の方法
  - `useReducer`は`useState`の書き換えのようなもので、規模が大きいアプリに向いている
  - `useState`は状態の更新の仕方を利用者が決め、`useReducer`は更新の仕方もあらかじめ状態側が決める
  - `useReducer`の使い方
    1. 現在の状態を保持する`state`とどのように状態を更新するかを示すオブジェクトである`action`の2つの引数を取る`reducer`関数を定義する
    2. `useReducer`をインポートして、第一引数に`reducer`関数、第二引数に初期値を渡して、分割代入で`state`と状態を更新するトリガーとなる`dispatch`関数を定義する
    3. 任意の関数で`dispatch`を使って、`action`を`reducer`に送り、状態の更新をトリガーする
  - `action`はどの更新方法を実行するかを決め、switch文で条件分岐を書くのが一般的
  - `useReducer`の第一引数は純粋関数になっている
  - inputの`value`の値は文字列になるので、数値として扱う場合は変換する必要がある
  - `useContext`の使い方
    1. `createContext`をインポートして、コンテキストを作る（初期値を指定する場合は引数に渡す）
    2. コンテキストの`Provider`で囲んで値を渡す
    3. 作成したコンテキストを使いたい場所でインポートして、`useContext`で値を定義する
  - `Provider`や`useContext`は別ファイルで定義したほうが良い
  - Contextを使っているコンポーネントはcontextが更新されると再レンダリングされる
  - 不要な再レンダリングは値ごとに`Provider`を作ると防げる
- 12章 useEffectとカスタムフック
  - 依存配列が更新されると`useEffect`のコールバック関数が実行される
  - 依存配列を`useEffect`内で更新すると無限ループになる
  - `useEffect`のコールバック関数内で関数を返すと、コンポーネントが削除されたときに実行される（クリーンアップ処理）
  - クリーンアップ処理はコンポーネントが消滅するタイミングで後始末を行いたいときに書く
  - `setInterval`は使用が終わったらメモリのためにクリアする必要がある
  - `useLayoutEffect`は`useEffect`と同じように書けるが、`useEffect`より先に実行される、また画面の反映よりも先にコールバック関数が実行される
  - `useEffect`は上から実行される
  - カスタムフックはhooksを内部で使った関数のこと
  - JSXの構築に関係ない処理はすべて副作用なので、`useEffect`かイベントハンドラに記述する
- 13章 ReduxとRedux Toolkit
  - Reduxは`useContext`と`useReducer`を合わせたような状態管理の仕組みで、React以外でも使える
  - Reduxを使うことで、`useContext`と`useReducer`よりも保守性や可読性が上がるので中規模のアプリでもReduxを使ったほうがいい
  - Redux Toolkitを使うことが推奨されており、Redux以外の便利なライブラリや関数も使うことができる
  - Reduxでもstateを使いたいコンポーネントを`Provider`で囲む
  - stateは`Store`に保持する
  - stateを使う時は`useSelector()`を使う
  - stateを更新する時は`useDispatch()`を使う
  - Reduxの仕組み
    - 1つのグローバルストアが準備されていてReducerを登録する
    - ReducerによってStoreに登録されているstateを更新する
    - Reducerを実行するためにDispatchでActionがStoreに送られる
    - ActionのTypeに一致するReducerが実行される
  - Reduxではstateを更新するのはReducerだけになる
  - Storeは複数のReducerを保持できる
  - 複数のReducerを使うと、Reducerごとにstateが作られるので、同じtypeがあるとどちらも変更されるので注意する（toolkitを使うと自動で別になる）
  - `ActionCreator`はdispatchで渡す`action`を定義する関数で、toolkitでは自動的に作られる
  - toolkitではストアは`configureStore`で定義する
  - toolkitでは`createSlice`に渡すオブジェクトで初期値や`reducer`を定義する
  - toolkitではreducerは`createSlice`に渡すオブジェクトの`reducer`プロパティとして定義し、`reducer`プロパティに渡すオブジェクト内のメソッドで処理を記述する
  - toolkitの中ではImmerが使われているので、ミュータブルな操作がイミュータブルに扱われる
  - プロキシによってミュータブルな処理がイミュータブルな処理に変換される
  - Immerを使うとネストされたミュータブルな値にも対応できる
  - Immerを使ってミュータブルな値を変更した場合は`return`を書かない
  - Reduxでの副作用のコードはMiddlewareに書く
  - Reducerに非同期処理は書かない
  - すべてのactionに対して共通処理を書きたい場合は`middleware`を使う（あまり使うことはない）
- 20章 テスト
  - テストがないとコードの改修時に影響範囲を調べる必要がある
  - 関連システムを含め、エコシステム全体に対して行うテストを一気通貫テストという
  - Jestは初期設定が不要
  - ViteのプロジェクトではJestに代わりVitestが使われる（Jestへの移行は容易）
  - `it`と`test`は同じ役割
  - Test Suitesはファイルごとで、Testsは1つずつのテストを指す
  - ReactでのJestを使ったテストでは、`test`のコールバック関数内でコンポーネントを擬似的にレンダリングして、要素を取得して`expect`を使ってテストを書く
  - テストで要素を取得する場合は機械的なタグではなく、実際にユーザーが使うアクセシビリティを使った情報や、テキストデータで取得する
  - テストコードはArrange（準備）、Act（実行）、Assertion（結果）の確認の順番で書く
  - 更新前もテストすると厳密にテストできる
  - `describe`を使うことでテストをまとめてわかりやすくできる
  - `useReducer`を使うことで関数のテストを書ける
  - `useState`だと、ユーザーの操作による状態の変化をテストする必要がある
  - オブジェクトを比較する場合は`toEqual`を使う
  - プリミティブを比較する場合は`toBe`を使う
  - ユーザーの操作をテストするときには`fireEvent`より忠実に画面の操作に合うように実装されている`userEvent`を使う
  - 外部APIは通信するたびに取得するデータが変わったり、APIのサーバーがダウンしていると、テストが失敗するのでモック化する
  - モック化では`jest.mock()`を使う

- オブジェクトのプロパティを動的に決めるには`[]`を使う

## わからなかったこと
- reduxでの非早期処理のstatusの管理

## エラー
- `Uncaught Error: Objects are not valid as a React child (found: object with keys {a, b, result}). If you meant to render a collection of children, use an array instead.`
  - オブジェクトをそのまま表示しようとした時のエラー
  - 解決方法：オブジェクトのプロパティにアクセスする


## 次やること
- udemy React完全入門ガイド
  - 17
  - 18
  - 19

## 感想
reducerのswitch文の中の処理の戻り値をどう返すか書くのが難しい。でもuseReducer使うとコードが統一される感じがして楽しい。慣れればどこにどのコードを書くとかすぐにわかってきそう。

スプレッド演算子を使いこなせないとだめ。

Redux、登場する要素多すぎて難しい。useContextとuseReducer学んでなかったらもっとわからんかったな。使うときにまた勉強すればいいや。

Jestも実際にテスト書いていかないと身に付かなさそう。