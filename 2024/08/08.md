# 8/8

## 取り組んだこと
- サバイバルTypeScript

## 学んだこと
### サバイバルTypeScript
- 本書について
  - 実務で死なないためのTypeScriptの知識をまとめたもの
  - 2章でTypeScriptの概要を知る
  - 3章でTypeScriptのアプリを作る
  - 4章で詳しい言語機能を学ぶ
  - 5章でよく使われるTipsを学ぶ
- 2章 TypeScriptのあらまし
  - TypeScriptはJavaScriptに静的型付けを追加したJavaScriptの上位互換で、大規模開発に適している
  - TypeScriptはJavaScriptにコンパイルされて実行される
  - 静的型付けは変数や関数の引数に型を指定すること
  - 型推論によって型を指定していなくてもコンテキストに基づいて型を推測する
  - オブジェクトがどのようなプロパティやメソッドを保持しているかという構造的部分型システムによって型を判断する
  - ジェネリクスによって汎用的で再利用可能なコードを書ける
  - オブジェクト指向型と関数型の両方をサポートしている
  - インターフェースをサポート
  - JavaScript同様、ガベージコレクションを使って自動的にメモリを解放する
  - JavaScriptの歴史
    1. JavaScriptは当初は補助的な立ち位置の言語
    2. AjaxによるGoogleMapによってJavaScriptのニーズが高まる
    3. 大規模開発に向けたjQueryやフレームワークの登場
    4. コンパイルして使うAltJSの普及
    5. JavaScriptのスーパーセット、モジュール、型を特徴とするTypeScriptの登場
    6. ES2015の発表
  - エコシステム
    - JavaScriptの仕様を定義したECMAScript
    - React等のUIライブラリ
    - Next.js等のフレームワーク
    - ライブラリの型定義ファイル
    - ブラウザとサーバーの実行環境
    - JavaScriptエンジン
    - パッケージマネージャー
    - ファイルを1つにまとめるモジュールバンドラー
    - ビルドなどの必要なタスクを行うタスクランナー
    - TypeScriptからJavaScriptに変換するトランスパイラー
    - コードの整形を行うコードフォーマッター
    - コードの静的解析を行うリンター
    - Gitにコミットやプッシュ時に何らかの処理を行うGitフック
  - 型の導入によって可読性や理解のしやすさが向上したり、エディタの保管を使えたり、バグを早期に発見できる
  - スーパーセットというのはJavaScriptの仕様そのままにTypeScriptの機能や利点を加えたもの
  - TypeScriptはES5以前の古いコードにコンパイルできる
  - 動的型付けは実行時に型が決まり、静的型付けは実行より前のコンパイル時に決まる
  - ブラウザの内部にはECMAScriptを実装したJavaScriptエンジンと画面の描画を行うレンダリングエンジンがある
  - TypeScriptの実行時パフォーマンスはJavaScriptと同じ
  - コンパイラは基本的に型を消すだけでパフォーマンスを最適化しない
- 3章 作って学ぶTypeScript
  - Node.jsはJavaScriptのサーバーサイドの実行環境で、Google Chromeと同じV8エンジンでJavaScriptを実行する
  - TypeScriptをコンパイルするにはNode.jsが必要
  - 型を指定することを型注釈という
  - コンパイラが生成したjsファイルを本番環境にデプロイする
  - Reactの特徴は仮想DOM、宣言的UI、コンポーネントベース
  - JavaScriptの中にHTMLを書けるものがJSXで、TypeScriptでは拡張子を`.tsx`にする
  - Next.jsはあらかじめWebpackの設定が行われた状態で開発ができる
  - Next.jsではページコンポーネントと認識させるため、`export default`でエクスポートする
  - ページコンポーネントでは`NextPage`の型を指定する
  - APIレスポンスの取り扱いはフロントエンドでバグが混在しやすい箇所なので、型を指定する
  - useEffectには非同期関数を直接渡すことはできない
  - JSXではJavaScriptの式だけを書けるので、if文は使えないため、三項演算子や論理演算子を使う
  - Next.jsではサーバーサイドレンダリングによって初回読み込み速度を向上させることができる
  - `next build`を実行することで本番環境用のコードを生成でき、`next start`で生成したコードを実行できる
  - Next.jsのホスティングサービスであるVercelを使うと、Github連携した時点で、自動デプロイのCI/CD環境が自動で構築される
  - JestはJavaScriptのフレームワークで、TypeScriptでも書ける
  - Jestに必要なパッケージは`jest`（Jest本体）、`ts-jest`（JestをTypeScriptに対応させる）、`@types/jest`（JestのAPIの型定義ファイル）
  - JestはそのままではTypeScriptを直接テストできないので設定する必要がある
  - Jestで関数をテストするにはエクスポートする必要がある
  - `testing-library`を使うことで、コンポーネントの描画や操作などをテストできる
  - コンポーネントのテストは、描画→状態の確認→操作→状態の確認の流れで行う
  - JestでコンポーネントのDOMと、テスト実行時のコンポーネントのDOMが一致するか確認するスナップショットテストを実行できる
  - スナップショットテストでは1回目のテストの実行でスナップショットテスト用のファイルを生成し、2回目で照合する
  - prettierを使って整形するには`yarn prettier --write`を使う、オプションを指定しないと整形結果が表示されるだけ
  - prettierの整形ルールを指定するにはコマンドのオプションか、`.prettierrc`などの設定ファイルを使う
  - ESLintは`--fix`オプションを指定すると自動で修正できる
  - TypeScript ESLintを動かすにはTypeScriptのコンパイラ設定を記述する`tsconfig.eslint.json`と、ESLintの設定ファイルである`.eslintrc.js`を作る必要がある
  - TypeScriptプロジェクトでは、コンパイルで生成されるJavaScriptは、リントしないのが普通


## 次やること
- サバイバル TypeScript
  - 4章
  - 5章

## 感想
Jestとかtesting-libraryとか初めて使ってみたけど、やってることほぼRSpecと同じだった。

WebpackとかBabelとかもがっつり触ってみたいし、設定方法をブログでまとめる。