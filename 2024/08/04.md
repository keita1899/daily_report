# 8/4

## 取り組んだこと
- udemy JavaScriptメカニズム
  - モジュール
  - this
  - プロトタイプ
  - 非同期処理

## 学んだこと
### udemy JavaScriptメカニズム
- モジュール
  - モジュールはJavaScriptでコードを機能ごとに分割して管理する仕組みで、`require`と`exports`を使う
  - CommonJSはNode.jsでモジュールを管理する仕組み
  - ESModuleはブラウザで使うECMAScriptの仕様に基づくモジュールの管理の仕組みで、`import`と`export`を使う
  - `import`はモジュールを読み込み、`export`はモジュールを外部から読み込めるようにする
  - モジュールを使うには`script`タグの`type`を`module`にする
  - 名前付きエクスポートだと、`import`で`{}`を使って、エクスポートした名前で読み込む
  - デフォルトエクスポートだと、`export default`と書き、`import`では`{}`を使わずに任意の名前を使える
  - ESModuleのインポートは即時関数で引数を使うのと似ている
  - ESModuleだとグローバルコンテキストがモジュールコンテキストになる
  - モジュールコンテキストではトップレベルで`this`が使えず（`undefined`になる）、スクリプトスコープがモジュールスコープになる
  - `type="module"`を指定した場合、ファイルは非同期で読み込まれる（`defer`が自動的に付与される）
  - 普通の`script`タグで非同期で読み込みたい場合は`defer`を指定する
  - モジュールは`script`で何回読み込んでも1回しか読み込まれない
  - `script`タグに`nomodule`を指定するとモジュールに対応していないブラウザでのみ実行される
  - `use strict`でStrictモードにすることで意図しないバグや予約語を防ぐ
  - モジュールは自動的にStrictモードになる
  - クラスのコンストラクタやメソッド内はデフォルトでStrictモードが有効になっている
  - ダイナミックインポートを使うと、モジュールを非同期で読み込める
    - `import('path').then(function(modules) {})`
- this
  - `this`は呼び出し元のオブジェクトへの参照を保持するキーワード
  - `this`は関数コンテキストで使うことが多い
  - `this`は実行コンテキストによって参照先が変わる
  - オブジェクトのメソッド内での`this`はオブジェクト自身を参照する
  - 関数内での`this`はグローバルオブジェクトを参照するため、メソッドを関数に格納するとWindowオブジェクトを参照する
  - コールバック関数でも関数を実行するのと同じであるため、`this`はWindowオブジェクトを参照する
  - `bind`によって`this`の値を固定した新しい関数を作る
  - `call`、`apply`では`this`を束縛し、同時に関数を実行する
  - `call`と`apply`の違いは引数の渡し方
  - `call`はそのまま、`apply`は配列で渡す
  - アロー関数では`this`を保持しないため、レキシカルスコープの`this`が参照される
- プロトタイプ
  - コンストラクタ関数は新しいオブジェクトを作成するための雛形の関数で、`new`演算子を使って実行することで、インスタンスを生成する
  - プロトタイプはオブジェクトに存在する特別なプロパティでコンストラクタ関数と一緒に使う
  - `Object.prototype`にメソッドを追加することでプロトタイプメソッドを定義する
  - `Object.prototype`にメソッドを追加することで、インスタンス化したときに`prototype`の参照が`__proto__`にコピーされる
  - プロトタイプではなく、コンストラクタ関数に直接メソッドを定義すると、各インスタンスでメソッドが作られる
  - プロトタイプメソッドだと、同じメソッドをインスタンス間で共有するのでメモリの効率化につながる
  - `instansof`を使うと内部でインスタンスの`__proto__`の参照先とコンストラクタ関数の`prototype`の参照先が同じか調べて、インスタンスがどのコンストラクタ関数から作られたかわかる
  - 関数コンストラクタは関数宣言と同じことをしているため、関数はオブジェクトである
  - 関数コンストラクタは基本的に使わない
  - プロトタイプチェーンは自身のオブジェクトから`Object`まで`__proto__`でメソッドがないか遡って探すこと
  - すべてのオブジェクトは`Object`の`prototype`から始まっているので、`prototype`にメソッドが定義されていなければ`undefined`になる
  - `hasOwnProperty`では自身のプロパティが定義されているか、`in`ではプロトタイプチェーンを使ってプロパティが定義されているか調べる
  - プロトタイプ継承は別のコンストラクタ関数のプロトタイプを受け継いで機能を使えるようにすること
  - ES6で追加されたJavaScriptのクラスはコンストラクタ関数をクラス表記で書けるようにしたシンタックスシュガー
- 非同期処理
  - スレッドは連続して実行される一本の処理の流れ
  - ブラウザにはメインスレッド、サービスワーカー、Web Workerなどのスレッドがある
  - メインスレッドでJavaScriptの実行とレンダリングが行われる
  - FPSは1秒あたりの画面の更新頻度で、30から60fpsだと画面がスムーズに更新される
  - 重いJavaScriptの処理があると画面が更新されなくなる
  - 同期処理ではメインスレッドでコードが順番に実行され、処理が終わるまで次の処理には進まない
  - `setTimeout`を使うことで、コールバック関数を非同期処理で実行できる
  - 非同期処理は一時的にメインスレッドから切り離される
  - タスクキューは実行待ちの非同期処理の行列で、タスクをキューの中で管理している
  - タスクキューは非同期処理の実行順を管理する
  - キューの仕組みを先入れ先出しなので、非同期処理はタスクキューに入ったものから実行される
  - イベントループはコールスタックにコンテキストが積まれているか定期的に確認し、空いていればタスクキューに空いていると通知する
  - コールバック関数を入れ子にすることで、非同期処理をつなげて実行できるが可読性が悪い
  - ES6で追加された`Promise`によってコールバック関数を使わずに非同期処理を書ける
  - `Promise`に渡したコールバック関数は同期処理で実行される
  - `Promise`では`resolve`を実行すると`then`が実行され、`reject`を実行すると`catch`が実行される
  - `then`を繋げて実行するとコールバック関数のネストと同じことができる
  - `then`の中で`catch`に移行したい場合は`throw`を書く
  - `finally`は必ず`then`か`catch`の後に呼ばれる
  - 次の`then`の引数に値を渡したい場合は`return`を使う
  - プロミスチェーンはPromiseを使って順番に非同期処理を実行すること
  - `Promise`オブジェクトのインスタンスを返すことで、プロミスチェーンを実現する
  - Promiseを並列で処理するには、`Promise.all`に反復可能オブジェクト（Promiseのインスタンス）を渡して実行する
  - マクロタスクはタスクキューで、マイクロタスクはタスクキューとは別で存在する非同期処理の待ち行列でジョブキューという
  - マクロタスクはマイクロタスクより後に実行される（setTimeoutはthenより後に実行される）
  - setTimeoutはマクロタスクで、Promiseはマイクロタスク
  - Async・AwaitはPromiseを同期処理的に書ける構文
  - `async`はPromiseを返す関数の宣言を行い、`await`はPromiseを返す関数の非同期処理が完了するまで待つ
  - `await`を使うと、Promiseの`resolve`の引数の値を返す
  - `await`を使うと非同期で実行されるため、非同期処理を扱う関数として、必ず関数自体に`async`をつける
  - `async`の関数自体もPromiseを返す
  - `fetch`サーバー上からデータを取得するブラウザのAPIで、Promiseを返す
  - JavaScriptでデータを取得するときはJSONで返すのが一般的
  - `Response`オブジェクトはサーバーからのレスポンスの情報を保持している
  - JSONを取得するには`response.json()`と書く
  - 例外処理を使って`throw`で例外を投げることで、開発する人によってエラー時の処理を切り離すことができる
  - `Error`を継承することでカスタムエラーを作ることができる

### rbenvとDockerの環境構築の違い
- rbenv
  - 特徴
    - ローカルのPCに直接Rubyをインストールし、異なるバージョンのRubyを管理できるツール
    - rbenvはシステムのRubyバージョンを変更するのではなく、プロジェクトごとにRubyのバージョンを切り替えることができる
  - メリット
    - rbenvはローカルの環境に直接インストールし、簡単にRubyバージョンを管理できる
    - プロジェクトごとに異なる Ruby バージョンを使用できるため、プロジェクトの依存性に対応しやすい
	  - Dockerのように仮想化やコンテナを使用しないため、オーバーヘッドが少なく、比較的軽量
  - デメリット
    - ローカル環境に依存するため、他の開発者との環境の一致が難しく、異なる開発者間での一致が保証されない
    - RubyのバージョンやgemのビルドがホストOSに依存するため、環境に依存する問題が発生する可能性がある
    - 複数のRubyバージョンやgemの管理が複雑になることがある
- Docker
  - 特徴
    - DockerをPCにインストールし、Docker上でコンテナを作成して、その中にRubyやその他の依存関係をインストールする方法
    - コンテナ内でアプリケーションを実行するため、環境が隔離され、他のシステムやアプリケーションと独立している
  - メリット
    - コンテナはどこでも同じように動作するため、他の開発者と環境を共有しやすく、環境の違いによる問題を減らすことができる
    - アプリケーションの依存関係や設定がコンテナ内に完結しているため、ホストシステムとの干渉を防ぐ
    - 開発環境と本番環境を一致させることで、デプロイ時のトラブルを減らすことができる
  - デメリット
    - Docker はコンテナを仮想化するため、少なからずリソースオーバーヘッドがある
    - 初期の設定やコンテナの管理がやや複雑で、学習コストがかかる場合がある
    - 特定の操作でパフォーマンスが低下する場合があり、特にホストシステムのリソースと競合することがある

## わからなかったこと
- `prototype`と`__proto__`の違い
- Promiseを繋げるのと、`then`で繋げることの違い
- `Promise.all`

## 次やること
- udemy React完全入門ガイド
  - 4
  - 5
  - 6
  - 7
  - 8
  - 9
  - 10
  - 11
- ブログ Rails モデル
- ブログ Rails ビュー

## 感想
参照ってよくでてくるけど、何を指してるかわからなくなる。

非同期処理難しすぎるからブログでまとめる。