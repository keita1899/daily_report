# 8/22

## 取り組んだこと
- udemy React完全入門ガイド
  - 17
  - 18
  - 19

## 学んだこと
### udemy React完全入門ガイド
- 17章 Next.js 14 （App Router）を使ったアプリの構築方法
  - 新規のプロジェクトではApp Routerで実装する
  - 現在はサーバーのキャッシュを使ったSSRが主流
  - App Routerは
  - `page.js`はリクエストが送信された時に表示するコンポーネントを書く
  - `RootLayout`は全てのレイアウトに適用される
  - `layout.js`がまず読み込まれて、`children`に`page.js`のコンポーネントが読み込まれる
  - パスが見つからない場合は`not-found.js`が読みこまれる
  - App Routerではフックがある場合は`use client`を書く必要がある
  - サーバー側で実行するための`use server`は基本は使わない
  - Next.jsでは基本的にはサーバー側で完結させる
  - クライアント側でレンダリングする部分はなるべく分ける
  - サーバーコンポーネントでは直接データを取得できる
  - Next.jsの`fetch`はブラウザ標準のものとは別で、Next.js独自の関数
  - Next.jsでは`fetch`でデフォルトでキャッシュを使う
  - `generateStaticParams`はダイナミックルーティングに当てはまる値を決めるメソッド
  - SGで生成されたファイルは`out/`に出力されるので、`out`をサーバーに配置すれば公開できる
  - ページのメタデータは`layout.js`の`metadata`のオブジェクトで設定できる
  - メタデータを動的にする場合は`generateMetadata()`を使う
  - Next.jsでAPIを作る時は`api/`に`route.js`を作り、HTTPメソッドごとに関数を作る
  - Server ActionsはREST API経由でのサーバー側のデータの更新を直接関数経由で行う
  - Server Actionsの関数には`use server`を記述する
  - `useFormState`は新しいReactのフックで、Server Actionsの結果を画面に表示することができる
- 18章 Next.js 12 （Pages Router）基本的な使い方
  - `next.config.js`はNext.jsの設定を書く
  - ディレクトリかファイル名に`[]`を使うことで、動的なルーティングを実装できる
  - ページが`index.js`だとURLで省略できる
  - 動的なルーティングと固定のルーティングでは固定のルーティングが優先される
  - ダイナミックルーティングは1つの階層に1つしか作れない
  - `getServerSideProps`はSSRを行うための関数
  - 動的ルーティングの値を取得するには、`context.query`または`useRouter`の`router.query`を使う
  - `useRouter`が返すオブジェクトはURLのパスの情報や画面遷移のメソッドの情報が格納されている
  - `router.push`で画面遷移できる
  - `router.replace`でも画面遷移できるが、履歴を上書きする
  - `router.back`で1つ前の画面に戻る
  - `router.reload`で画面を更新する
  - `Link`コンポーネントを使わずにaタグを使うと画面が更新される
  - クエリパラメータは文字列で取得される
  - `next.config.js`で`rewrites`を設定することで実際のURLとは異なるURLでアクセスできる
  - `_app.js`はページを開いた時に必ず実行されるコンポーネントなので、グローバルなstateを使う時は`_app.js`でProviderを使う
  - `Head`はheadタグに挿入するタグを書く
  - `Script`コンポーネントは外部スクリプトを読み込み時に使うが、ほぼ使わない
  - `pages`に外部からアクセスされてはいけないファイルは置かない
  - 静的なリンクには`Link`を、何らかの処理をきっかけに画面遷移を行う場合は`useRouter`を使う
- 19章 Next.js 12 （Pages Router）SSRとSG、API Routes
  - Next.jsではCSR、SSR、SG、ISRのレンダリング方法があるが、SSRとSGがよく使われる
  - CSRはクライアントサイドレンダリングで全ての処理がクライアント上で行われる
  - Next.jsでクライアント側での処理のみを行いたい時は`useEffect`を使う
  - SSRはサーバーサイドレンダリングでサーバー側で動的にHTMLを生成する
  - SSRは外部APIへのデータ取得やコンポーネントのpropsの値を決定する処理を行い、HTMLを作成してクライアント側に返却する
  - SGは静的サイト生成で、リクエスト時ではなくビルド時にデータを取得しHTMLを生成する
  - Next.jsでは基本的なページはSGで作り、動的な変更が多い場合はSSRで作る
  - ISRはビルド時にHTMLを構築し、一定時間後のアクセスでサーバー側でHTMLを更新する
  - ISRはサーバーの設定が手間であるデメリットがある
  - Next.jsではNode.js上とブラウザで関数コンポーネントが実行される
  - Next.jsでは仮想DOMを使って擬似的にNode.js上でDOMツリーを作成し、値を代入してHTMLを返す
  - SSRではブラウザのwindowなどは使えないので使いたい場合は`useEffect`を使う
  - SSRは初期表示で、画面遷移ではCSR
  - `getServerSideProps`はNode.js上で実行されるので、コンソールには表示されない
  - `getServerSideProps`はページコンポーネントでしか使えない
  - `getServerSideProps`の引数の`context`には通信の情報が格納される
  - Next.jsでは他の画面から遷移してきた場合はCSRになるが、ページコンポーネントで使用する`pageProps`はNode.jsからJSON形式で受け取る
  - SGはHTMLを出力するもの
  - SGはいくつかパターンがある
    - export - ビルドしたものをHTMLとして出力する
  - `getStaticProps`はビルド時に実行され、戻り値がjsonで保存される
  - SGではあらかじめファイルを生成するので、ダイナミックルーティングでの値を取得できない
  - SGでダイナミックルーティングを使う時は`getStaticPaths`を使う
  - `getStaticPaths`はビルド時に実行され、動的なパスを事前に生成するために使う
  - `getStaticPaths`の`params`は`getStaticProps`の`context`で取得できる
  - `npm export`だと`out/`に静的ファイルを出力する
  - `npm start`は
  - `fallback`は`false`にすると`npm start`を実行した時に`getStaticPaths`に定義されていないパスにアクセスした時に404になる
  - `ISR`はVercelだとうまく動くが、他のホスティングサービスだと設定が難しい
  - `ISR`は`getStaticProps`の`return`に`revalidate`を追加するだけ
  - `revalidate`には秒数を指定する
  - API RoutesはNext.js上で簡易的なAPIを作る機能
  - プロトコル、ドメイン、ポート番号が同一のものが同一オリジン
  - クライアントサイドからリクエストを送信する際は外部サービスのAPIのURLは一般的にはバックエンドで集約して隠蔽する
  - Next.jsでは開発環境には`.env.development`、本番環境では`.env.production`に環境変数を設定する
  - 環境変数を取得する場合は`process.env.`を使う
  - 環境変数によって実行する環境によって自動的に値が切り替わる

## Next.jsのレンダリング
### 特徴
- CSR
  - Reactのレンダリング
  - クライアント側でレンダリングを行う
  - SEOに弱い
  - 初期表示が遅いが、ページ遷移は高速
- SSR
  - リクエストごとに
  - `getServerSideProps`でデータを取得する
  - サーバー側でレンダリングを行う
  - 初期表示が速い
  - SEOに強い
  - 最新のデータを表示できる
  - サーバーの負荷が大きい
- SG
  - ビルド時に静的なページが生成される
  - `getStaticProps`で
  - 初期表示が高速
  - SEOに強い
  - 頻繁にデータが更新されるページには向いていない
- ISR
  - ビルド時に`getStaticProps`が実行され、静的なページが生成される
  - 一定時間ごとにページを再生成する
  - SSRとSGの中間のようなレンダリング

### 流れ
- CSR
  1. リクエストが送信されると、サーバーから最小限のHTMLとJavaScriptがダウンロードされる
  2. クライアント側でJavaScriptが実行され、Reactのコンポーネントがレンダリングされる
  3. データが必要な場合はクライアント側でデータを取得してレンダリングする
- SSR
  1. リクエストが送信されると、サーバーが`getServerSideProps`によって必要なデータを取得する
  2. 取得したデータを使ってサーバー上でHTMLを作成しクライアントに送信する
  3. クライアントがサーバーから取得したHTMLを表示する
- SG
  1. ビルド時にサーバー側で`getStaticProps`で取得したデータを使ってHTMLファイルが生成される
  2. リクエストがあれば静的なファイルを返す
  3. 更新が必要な場合はビルドする必要がある

## わからなかったこと
- Next.jsでレイアウトを切り替える方法
- `Script`コンポーネントの使い方
- SGのexport
  - `next build`はすべてのレンダリングをサポートし、`next export`はSGだけをサポートする
- どこがSSRかSSGかわからなくなる
- API Routesを使ったAPIの隠蔽

## エラー
アロー関数でコンポーネントを書く時は以下の書き方はエラーになる。
```js
export default Home = () => {
  return (
    <h1>Home</h1>
  )
}
```

正しくはこう書く。

```js
const Home = () => {
  return (
    <h1>Home</h1>
  )
}

export default Home
```

## 次やること
- TypeScriptとReact/Next.jsでつくる実践Webアプリケーション開発
  - 1
  - 2
  - 3

## 感想
SSRとSGの使い方はちゃんと理解したい。

App Routerの方が簡単に設定できる気はするけど、使う時にまた学ぶ必要ある。