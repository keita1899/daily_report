# 9/15

## 取り組んだこと

- りあクト 1 言語・環境編
  - 1
  - 2
  - 3
  - 4

## 学んだこと

### りあクト 1

- まえがき
  - React 固有の決まり事は実際他のフレームワークより少ない
  - 技術の歴史を知ることで初めて正しく使えるようになる
  - React はフルスタックのフレームワークではないので、それなりの規模のアプリを開発するには他のライブラリを組み合わせる必要がある
  - 正しく技術選定できるようになるには歴史と、思想のトレンドを知る必要がある
- 1 章 こんにちは React
  - `node`コマンドで JavaScript を対話環境で実行できる
  - VSCode は TypeScript と相性がよく、型の整合性チェックや null 安全性のチェックを自動でやってくれる
  - VSCode はリモート開発機能が充実していて、Live Share による同時コーディングもできる
  - Create React App によって`react`、`react-dom`、`react-scripts`の 3 つのパッケージの最新バージョンがインストールされる
  - `react-scripts`は 50 個以上のパッケージが隠蔽されていて、Babel、Webpack、Jest 等を設定を行わずに使えるようになる
  - CRA は頻繁に使うコマンドではないので、毎回アップデートしながら使うより、ネット経由で最新版を直接実行した方がいいので、グローバルインストールすることは非推奨
  - `npx`はパッケージがインストールされていればそれを使い、なければ最新版をダウンロードして実行し、実行後はパッケージを削除する
  - `npx`は npm と同時にインストールされている
  - `yarn install`は`yarn`で実行できる
  - npm-scripts 実行時には自動的に`node_modules/.bin/`にパスが通される
  - npm-scripts には予約キーワードが存在する
  - `react-scripts eject`を実行すると隠蔽されていたパッケージが`package.json`の`dependencies`に現れ、ルートに`config/`が作られ、その中に設定ファイルが置かれる
  - `eject`は一度実行すると元に戻せない
- 2 章 JavaScript の世界
  - JavaScript は古いブラウザが動かなくなる状況を避けるために後方互換性を重視する言語
  - `var`はスコープが関数なので、ブロックをすり抜ける
  - 関数式は Function オブジェクトを生成するリテラルである
  - 無名関数は名前がないのでメモリに残らない
  - 関数の設計として重要な引数ほど前に持ってくるべき
  - クラスの実態はコンストラクタ関数
  - JavaScript のコンストラクタ関数はプロトタイプオブジェクトを継承してオブジェクトインスタンスを生成するための独立した関数
  - プロトタイプベースは直感的にわかりにくく、自由度が高いので大規模開発には向かないが、クラスよりは軽量
  - JavaScript の構文は命令型プログラミング言語である Java から多くの言語を借用してきている
  - 1 階層目のプロパティが存在していないと undefined が返り、2 階層目だとタイプエラーになる
  - プロパティに`?`を使えば、存在していなかったとしても undefined が返される
  - 0 や空文字をスルーする`||`より`??`の方が厳密
  - this は暗黙の引数と考えた方が理解しやすい
  - this の問題を避けるためには、クラス構文だけで使い、クラスの中のメソッドを含めたあらゆる関数の定義はアロー関数で行うべき
  - CommonJS はモジュールの読み込みが同期的で、ネットワークのオーバーヘッドが大きいフロントエンドでは順番にロードする待ち時間が長い
  - `require`と`exports`は条件分岐でもループでもどこでも呼べてしまう
  - Webpack はさまざまなモジュール構文をサポートしていて、構文を自動で適切に解釈して、異なるモジュール構文でも依存関係を解決してバンドルしてくれる
  - CRA の生成したプロジェクトでは Babel Loader 経由で、ES2015 の JavaScript や JSX、TypeScript がコンパイルされてバンドルされる
  - 最終的にモジュールシステムは ESModule に統一されるかもしれないが、パフォーマンスやバンドラ以外の役割から、モジュールバンドラがなくなる可能性は低い
  - Node で ESModule を使うには`package.json`で`"type": "module"`を記述する必要がある
  - モジュールの集約を行うことでインポート文を少なくできる
- 3 章 関数型プログラミング
  - 同じ入力に対して同じ出力が保証されていることを参照透過性という
  - プログラミングのパラダイムは命令型と宣言型に分かれる
  - 命令型は最終的な出力を得るために状態を変化させる連続した文によって記述されるスタイルで、手続き型とオブジェクト指向が代表的
  - 宣言型は出力を得る方法ではなく、出力の性質・あるべき状態を宣言するスタイル
  - 宣言型で複雑な処理を行わせるための方法が関数型
  - 関数型では再代入や破壊的な変更がされないので、不変性を守り予測しやすいコードになる
  - 関数型では代入をできるだけ避けるために、メソッドチェーンや演算子で式を繋いで、関数もその場限りなら無名関数を使う
  - 手続型は文を多用し、関数型は式を組み合わせる
  - 関数型は完成系を見据えて絞り込まれていくコードになりやすい
  - `reduce()`は第二引数に配列の各要素の値が順番に入り、第一引数には前回の関数の実行結果が入る、最終的に最後に実行された値が返される
  - `sort()`は破壊的メソッド
  - 関数型では`for..of`や`forEach`は外部のミュータブルな変数を書き換える副作用を起こすので、使わずに`map`や`find`等を使う
  - JavaScript は歴史的経緯から納得しにくい仕様が多く残る言語
  - 関数は関数を返せる
  - 関数型では次のことが行われる
    - 変数に関数を代入できる
    - 関数の引数として関数を渡したり、戻り値として関数を返すことができる
    - 関数に特定の引数を固定した新しい関数を作ることができる
    - 複数の高階関数を合成して一つの関数にできる
  - カリー化とは複数の引数を取る関数を、より少ない引数を取る関数に分割して入れ子にすること
  - クロージャとは関数を関数で閉じて包むこと
  - 一般的なメモリのライフサイクル
    1. 必要なメモリを割り当てる
    2. 割り当てられたメモリを使用する
    3. 必要がなくなったら、割り当てたメモリを解放する（JavaScript はガベージコレクタによって行われる）
  - スコープから外れたものが参照されなくなると GC によって削除されるが、参照されていると残される
  - 関数コンポーネントはクロージャであることが多い
  - Promise 以前ではコールバックを使うしかなかった
  - コールバックを使うと処理の順番は保証されるが、入れ子になって可読性が下がる
  - Promise オブジェクトを自分で作る機会は少なく、何らかのライブラリを使ったときに返してくるものをそのまま使うことが多い
  - `resolve`に渡したものが`then`のコールバック関数の引数として受け取れ、`then`で return した値が次の`then`で受け取れる
  - コールバック関数は可読性が低いので、Promise の`then`で繋げるより、async・await を使う方が良い
  - async をつけた関数は非同期関数となり、`Promise.resolve()`によってラップされたものを返す
- 4 章 TypeScript

  - TypeScript がメジャーになった理由は静的型付け、型推論、Null 安全性というトレンドを押さえつつ、JavaScript と同じ構文を使えること
  - プログラムで一番多いバグは null アクセスの例外
  - Deno では直接 TypeScript を実行できる
  - `Array<string>`より`number[]`の書き方が推奨される
  - インターフェースの`[key: string]: number`のような書き方をインデックスシグネチャといい、任意のキーのプロパティを追加できる
  - インデックスシグネチャのキーに使える型は、文字列と数値のみ
  - TypeScript の`enum`はデフォルトが数値で、かつ型安全が保証されない
  - リテラル型は単独ではあまり使い道がないが、`|`でならべることによって列挙型のように使える
  - `enum`より文字列リテラル型の方がシンプルで、コンパイル後のコードも短くなる
  - タプル型は型と順番と個数がきまっている関数の引数などに使われる
  - `unknown`型は`any`型と異なり、それ自体は何のプロパティもプロトタイプメソッドも持たない
  - `never`型を使うことで、`case`文の漏れを未然にチェックできる
  - 関数の戻り値の型は型推論で省略できるが、引数の型は必ず指定する必要がある
  - React でコンポーネントを関数で定義する時は引数と戻り値の型をそれぞれ定義するのではなく、`React.FunctionComponent<P>`として提供されている関数の型を適用することが多い
  - 今日のオブジェクト指向では継承よりも合成のスタイルが優勢になっている
  - 継承は子クラスが親クラスに依存するため、影響範囲の予測が難しい
  - props と合成はコンポーネントの見た目と振る舞いを明示的かつ安全にカスタマイズするのに十分な準軟性を備えている
  - クラスの型を抽象化して定義する方法が抽象クラスと、インターフェースの 2 種類の方法があるが、抽象クラスではなくインターフェースを使うべき
  - TypeScript ではクラスを定義するとクラスインスタンスのインターフェース型宣言とコンストラクタ関数の宣言が同時に実行される
  - TypeScript のクラスは型であり関数でもある
  - インターフェースは既存の型を同じ名前で拡張できてしまうのでバグに繋がりやすい
  - インターフェースより型エイリアスを優先して使うべき
  - React アプリの開発なら型エイリアスを一貫して使う
  - `&`はプリミティブに使うと`never`になるので、オブジェクトの合成に使われる
  - null 安全性を保証するには`tsconfig.json`で`strictNullChecks`を true にする
  - 非 Null アサーション演算子`!`はコンパイラに絶対に null も undefined も入らないと黙らせて null 安全性を壊すものなので使わない
  - `typeof`を型のコンテキストで使うと変数から型を抽出できる
  - 型アサーションは最後の手段で、その前に型ガードを使う
  - TypeScript はモジュールについては言語レベルで ESModules を採用している
  - TypeScript でのインポートは拡張子を指定しない
  - TypeScript では変数や関数と同一の名前の型を持つことができ、同時に両方エクスポートされる（型のみのインポート・エクスポートもある）
  - ローカルの型宣言が最も優先度が強く、型定義の探索ではまっさきに適用され、次にモジュールがパッケージ内に持っている型ファイル、最後が`node_modules/@types`という順番
  - `tsc`は TypeScript のコンパイルコマンド
  - `tsconfig.json`の`strict`を true にすると複数のオプションがまとめて有効になる
  - CRA では TypeScript のコンパイルは Babel（`@babel/preset-typescript`） が行っている

## わからなかったこと

- モジュールの集約
- カリー化
- `never`型の使い道
- インターフェースの説明
- 高度な型表現

## 次やること

- りあクト 2
  - 5
  - 6
  - 7
  - 8
  - 9

## 感想

りあクトめっちゃ説明が詳しいし、対話形式で進んでいくからわかりやすい。

たまに詳しすぎて逆に難しくなる時もある。クロージャとか久しぶりすぎていまいちわからん。

TypeScript はまた読み直さないと今の段階ではちょっとわからない。高度な型の表現とかまじで難しい。tsconfig.json の設定とかもまたブログの記事でまとめる。
